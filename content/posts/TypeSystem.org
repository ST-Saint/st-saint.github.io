#+title: Type System
#+date: Sat Feb 04 22:04:44 PST 2023
#+katex: true
#+STARTUP: latexpreview
#+summary: I don't know what is type system

* Terminology

** Judgement
- A judgement is something we may know, that is, an object of knowledge
- A judgement is evident if we in fact know it

- \(e:t\) \Rightarrow the expression e has type t

- \(\Gamma\) \Rightarrow Context: a set of <variable, type> pairs

  + \(\vdash\) \Rightarrow turnstile

  + \(\Gamma \vdash e : t\) \Rightarrow expression e has type t in the context \(\Gamma\)

  + \(\Gamma , x:\tau\) \Rightarrow extends \(\Gamma\) with knowledge: \(x:\tau\)

** Inference Rules

- \(\frac{P1\ P2\ P3\ ...}{C}\)
  + C \Rightarrow conclusion
  + P \Rightarrow premise
  + If we konw P1 & P2 & P3 then we know C


*** Derivation
#+begin_quote
In ML, a typing derivation is a proof that some expression can have some type, given a particular context, not that the expression can only have that type or that the expression will have that type no matter where we encounter it.

a derivation for ρ ⊢ e : t is a proof that in some context ρ (which assigns types to variables in e), we can show that e can have (at least) the type t, and possibly others.
#+end_quote

- The one-step evaluation relation → is the smallest binary relation on terms
- When the pair (t , t') is in the evaluation relation, we say that "the evaluation statement (or judgment) t → t' is derivable."

**** Derivation Tree
\begin{equation}
\notag \large \dfrac{\dfrac{\dfrac{x:Bool \in x: Bool}{x:Bool \vdash x:Bool}}{\vdash \lambda x:Bool . x : Bool \rightarrow Bool} \qquad \dfrac{}{\vdash true: Bool} }{\vdash (\lambda x: Bool.x )\ true: Bool}
\end{equation}

\begin{align*}
x&=\sqrt{b} \\
&=b^{\frac{1}{2}}
\end{align*}
** Reduction
- Also known as *subject evaluation*, *type preservation* or simply *preservation*

$$\frac{\Gamma \vdash e_1:\tau\qquad e_1 \rightarrow e_2}{\Gamma \vdash e_2:\tau}$$

$$\frac{}{if\ True\ then\ e1\ else\ e2 \rightarrow e1}$$

- $$\frac{e \Downarrow True}{if\ e\ then\ e1\ else\ e2}$$ $${if\ True\ then\ e1\ else\ e2\ \rightarrow\ e1}$$

** Substitution

- $$e[x \backslash e^a]$$

$$[x \rightarrow e^{'}]e \Rightarrow [ x \rightarrow e^{'}](let y=e_1\; in\; e_2 ) = let y=[x \rightarrow e^{'}]e_1\; in\; [x \rightarrow e^{'}]e_2 $$

** Unification

** landin' knot
- represent recursion
  + 13.5.8

* Refinement Types

** Introduction
- programs can do things wrong:
  1. Divided by zero
  2. Buffer overflow
  3. mismatched dimension
     - wrong type casting
  4. logic bug
     - integer range [min, max]
  5. Correctness error
- Refinement type system uses predicates to enrich the type information

*** passes
1) STCL
2) branch conditions -- path-sensitive
3) infer refinements
4) type polymorphism -- context-sensitive
5) polymorphic data types
6) refinement polymorphism for different invariants
7) verify termination???
8) proof proposition over UDF

** Simply Typed \lambda-calculus
- primitive constants: =nat=
- primitive operations: =add=
- function type with constrain

*** Verification Conditions
- take the annotated program as input and return a VC

*** arithmetic overflow
- seems like we can simply add a upper bound (2^31 or 2^63) to avoid overflow here

** Branches and Recursion
- also convert to branches conditions to similar VC

** questions
*** Differences between refinement type system and symbolic execution
- To formally verify the division by, buffer overflow and integer range problems, refinement type system also add predicates and constrains over variable and use SMT solver to resolve these constrains, so what does refinement types do differently? or actually symbolic execution is one component of refinement type system?
*** what would the refinement type system do if the conditions cannot be solved by SMT?
- if the condition cannot be satisfied, then it should be a logic bug?
*** it is a bit confusing that how could you verify termination with a recursion function?

* Sized Types
- Input makes the program unpredictable. The inputs can taint data or even the control-flow, making memory mess and analysis tricky.
- Sized type system is to
  - check computation of each stream element terminates.
  - express bounds on the sizes of recursive data structures.

** productive
- a request for the first ~i~ element of the stream is guaranteed to be processed in finite time means the program is productive
- I guess =head= is to read the first element of a stream and =tail= is the stream excluding the first element
- so we introduce type: ~ST^i~ for streams with at least i elements
- using sized types we can infer the lower bounds on the size of all the streams
- if we can claim a function has a type: ~ST^i -> ST^j && i>j~ then we can prove termination

** Primitive Recursion: Reverse
- sized type system can prove termination or productivity of functions in primitive recursive form

#+begin_src lisp
reverse :: \forall i. \forall t. LIST_i t -> LIST_i t
reverse xs =
case xs of
Nil -> Nil
Cons y ys -> append (reverse ys) (Cons y Nil)
#+end_src

1. =Nil -> Nil= has type ~LIST_{i+1} t~ (why i+t though)
2. append (Reverse ys) (Cons y Nil) :: LIST_{_{i+1}} -> t

*** Accumulating Parameters
- allow a limited form of polymorphic recursion: over sizes, but not types.

** Array Bounds Check
- We view an array as a function from indices to contents
  - an array of t with 6 elements has type ~NAT_6 -> t~

** questions
- I guess ~Mk~ and ~ST~ are all special keywords and ~ST~ is stream. However I still don't get what how to combine a ~NAT~ and a ~ST~
- Sized Type consider the length of the stream instead the value of streams. I think the value of input is also important. For example, the Array Bounds Check problem, a common scenario is the array having a dynamic length (i.e. depends on input), and the length becomes unknown to tpye system. So if we want to constrain the input refinement type sounds more reasonable but it will probably become a SAT problem. Even though I feel memory allocation is still a conflict between efficiency and safety. If you allow dynamically length it is more tricky to prove the safety but you gain some flexibility. Is it possible to combine sized type and refinement type to check more security properties of the program?
