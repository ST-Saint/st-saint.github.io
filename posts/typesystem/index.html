<!doctype html><html lang=en dir=auto><head><script src=https://kit.fontawesome.com/26b1a93730.js crossorigin=anonymous></script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Type System | Yayu Wang</title><meta name=keywords content><meta name=description content="I don't know what is type system"><meta name=author content="ST_Saint"><link rel=canonical href=https://st-saint.github.io/posts/typesystem/><link crossorigin=anonymous href=/assets/css/stylesheet.min.75e61ebd60ddecacae8c6556883264fec881116b33bcce32a3a8b85f3208d5f7.css integrity="sha256-deYevWDd7KyujGVWiDJk/siBEWszvM4yo6i4XzII1fc=" rel="preload stylesheet" as=style><link rel=icon href=https://st-saint.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://st-saint.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://st-saint.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://st-saint.github.io/apple-touch-icon.png><link rel=mask-icon href=https://st-saint.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(146, 146, 151);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Type System"><meta property="og:description" content="I don't know what is type system"><meta property="og:type" content="article"><meta property="og:url" content="https://st-saint.github.io/posts/typesystem/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-04T22:04:44+00:00"><meta property="article:modified_time" content="2023-04-02T00:01:38-07:00"><meta property="og:site_name" content="ST_Saint Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Type System"><meta name=twitter:description content="I don't know what is type system"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://st-saint.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Type System","item":"https://st-saint.github.io/posts/typesystem/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Type System","name":"Type System","description":"I don\u0026#39;t know what is type system","keywords":[],"articleBody":" Terminology Judgement A judgement is something we may know, that is, an object of knowledge A judgement is evident if we in fact know it \\(e:t\\) ⇒ the expression e has type t \\(\\Gamma\\) ⇒ Context: a set of pairs\n\\(\\vdash\\) ⇒ turnstile \\(\\Gamma \\vdash e : t\\) ⇒ expression e has type t in the context \\(\\Gamma\\) \\(\\Gamma , x:\\tau\\) ⇒ extends \\(\\Gamma\\) with knowledge: \\(x:\\tau\\) Inference Rules \\(\\frac{P1\\ P2\\ P3\\ ...}{C}\\)\nC ⇒ conclusion P ⇒ premise If we konw P1 \u0026 P2 \u0026 P3 then we know C Derivation In ML, a typing derivation is a proof that some expression can have some type, given a particular context, not that the expression can only have that type or that the expression will have that type no matter where we encounter it.\na derivation for ρ ⊢ e : t is a proof that in some context ρ (which assigns types to variables in e), we can show that e can have (at least) the type t, and possibly others.\nThe one-step evaluation relation → is the smallest binary relation on terms When the pair (t , t') is in the evaluation relation, we say that \"the evaluation statement (or judgment) t → t' is derivable.\" Derivation Tree \\begin{equation} \\notag \\large \\dfrac{\\dfrac{\\dfrac{x:Bool \\in x: Bool}{x:Bool \\vdash x:Bool}}{\\vdash \\lambda x:Bool . x : Bool \\rightarrow Bool} \\qquad \\dfrac{}{\\vdash true: Bool} }{\\vdash (\\lambda x: Bool.x )\\ true: Bool} \\end{equation} \\begin{align*} x\u0026=\\sqrt{b} \\\\ \u0026=b^{\\frac{1}{2}} \\end{align*} Reduction Also known as subject evaluation, type preservation or simply preservation $$\\frac{\\Gamma \\vdash e_1:\\tau\\qquad e_1 \\rightarrow e_2}{\\Gamma \\vdash e_2:\\tau}$$\n$$\\frac{}{if\\ True\\ then\\ e1\\ else\\ e2 \\rightarrow e1}$$\n$$\\frac{e \\Downarrow True}{if\\ e\\ then\\ e1\\ else\\ e2}$$ $${if\\ True\\ then\\ e1\\ else\\ e2\\ \\rightarrow\\ e1}$$ Substitution $$e[x \\backslash e^a]$$ $$[x \\rightarrow e^{'}]e \\Rightarrow [ x \\rightarrow e^{'}](let y=e_1\\; in\\; e_2 ) = let y=[x \\rightarrow e^{'}]e_1\\; in\\; [x \\rightarrow e^{'}]e_2 $$\nUnification 推导 (deduction) landin' knot represent recursion\n13.5.8 Refinement Types Introduction programs can do things wrong:\nDivided by zero Buffer overflow mismatched dimension\nwrong type casting logic bug\ninteger range [min, max] Correctness error Refinement type system uses predicates to enrich the type information passes STCL branch conditions – path-sensitive infer refinements type polymorphism – context-sensitive polymorphic data types refinement polymorphism for different invariants verify termination??? proof proposition over UDF Simply Typed λ-calculus primitive constants: nat primitive operations: add function type with constrain Verification Conditions take the annotated program as input and return a VC arithmetic overflow seems like we can simply add a upper bound (2^31 or 2^63) to avoid overflow here Branches and Recursion also convert to branches conditions to similar VC questions Differences between refinement type system and symbolic execution To formally verify the division by, buffer overflow and integer range problems, refinement type system also add predicates and constrains over variable and use SMT solver to resolve these constrains, so what does refinement types do differently? or actually symbolic execution is one component of refinement type system? what would the refinement type system do if the conditions cannot be solved by SMT? if the condition cannot be satisfied, then it should be a logic bug? it is a bit confusing that how could you verify termination with a recursion function? Sized Types Input makes the program unpredictable. The inputs can taint data or even the control-flow, making memory mess and analysis tricky. Sized type system is to\ncheck computation of each stream element terminates. express bounds on the sizes of recursive data structures. productive a request for the first i element of the stream is guaranteed to be processed in finite time means the program is productive I guess head is to read the first element of a stream and tail is the stream excluding the first element so we introduce type: ST^i for streams with at least i elements using sized types we can infer the lower bounds on the size of all the streams if we can claim a function has a type: ST^i -\u003e ST^j \u0026\u0026 i\u003ej then we can prove termination Primitive Recursion: Reverse sized type system can prove termination or productivity of functions in primitive recursive form 1 2 3 4 5 reverse :: \\forall i. \\forall t. LIST_i t -\u003e LIST_i t reverse xs = case xs of Nil -\u003e Nil Cons y ys -\u003e append (reverse ys) (Cons y Nil) Nil -\u003e Nil has type LIST_{i+1} t (why i+t though) append (Reverse ys) (Cons y Nil) :: LIST_{i+1} -\u003e t Accumulating Parameters allow a limited form of polymorphic recursion: over sizes, but not types. Array Bounds Check We view an array as a function from indices to contents\nan array of t with 6 elements has type NAT_6 -\u003e t questions I guess Mk and ST are all special keywords and ST is stream. However I still don't get what how to combine a NAT and a ST Sized Type consider the length of the stream instead the value of streams. I think the value of input is also important. For example, the Array Bounds Check problem, a common scenario is the array having a dynamic length (i.e. depends on input), and the length becomes unknown to tpye system. So if we want to constrain the input refinement type sounds more reasonable but it will probably become a SAT problem. Even though I feel memory allocation is still a conflict between efficiency and safety. If you allow dynamically length it is more tricky to prove the safety but you gain some flexibility. Is it possible to combine sized type and refinement type to check more security properties of the program? typing vs typechecking 顶不住了, 先看看中文文档吧 typing-vs-typechecking 本体论(Ontology) 类型是一种抽象的实体(entity) 类型不是名称 类型 = 分类？ 不是 不是为了对现有对象\"分类\", 因为被“分类”的对象都是先前毫无意义, 只是通过这个类型才确定的, 而且具有这样类型的值 只可能有一种完全等价的 构造方式, 这就是所谓的 unit type 的实例 类型是什么 对于某个类型系统中的类型——这种人为设计中的一份子 类型系统的设计者或者类型的设计者（类型系统的用户）希望它是什么 历史上的类型是什么 罗素悖论 - 类型论\n任给一个性质(例如：\"年满三十岁\"就是一个性质)，满足该性质的所有集合总可以组成一个集合 设有一性质P，并以一性质函数表示：P(x)，且其中的自变量x有此特性： x ∉ x，\n不是, x ∉ x 是什么意思 我靠我一直觉得 PL 讲的 type 本质都应该是数学集合, 好像还是有点道理, 然而类型系统好像是集合论的上位(也许)替代 类型的意义 各种类型论中, 并没有要求\"类型\"成为和某种领域外实体的对应, 以作为建模或\"分类\"的基础, 而仅仅是项 (term) 上关联的一些抽象实体 派生概念 类型正确(Type Correctness) 符合期望 类型是开发者对数据、对实体属性的描述, 显式类型是开发者对于程序设计的理解和限定的直接描述\n原文对可读性和重构的考虑脱离实际 使用 var, auto 借用 Type inference 省去对数据的描述是让开发者在上下文中丢失对数据的理解, 且不便于第三方审阅代码; 在重构时, 考虑代码改动对数据, 对上下文的影响是非常重要且易错的环节, 显式类型要求开发者对语义的改变进行考虑(当然如果开发者匆匆掠过是另一个问题), 类型推断提供了开发便利但不利于保证程序正确性 即使使用 var, auto ，一个不可忽视的事实是, 编译器生成的 binary 并不包含 var 类型, 实际 runtime 类型有且只有一个具体类型(如果有 runtime type), 如果没有 runtime type 那么数据就只是纯粹的数据而不带任何限制, 这与源代码中 var, auto 所表达的类型不匹配, 而开发者因代码和运行时的差异对程序行为做出错误预测是非常不理想的设计缺陷 一个可以接受的选择是type system在编译前就将 auto 替换成具体类型 类型识别(Type Identification) 要判断类型是否相同, 比较给定的表示类型的数据结构（类型标识）和已知类型的对应数据结构是否相等 类型转换(Type Conversion) 强制(coercion) 是一种隐式转换 多态(ad-hoc polymorphsim) 而和铸型(casting) 显式转换 类型安全(Type Safety) 较常用的一种安全机制的基本思路是，定义类型是某个域(domain)中值的集合, 保证类型安全即约束需要考察的值总是符合某一些类型的约束.\n判断对象语言描述的程序是否符合类型安全这项任务能被程序表达和实现(包括语言自身的实现, 如编译时的检查). 这样, 类型安全可以视为某一些语言规则中蕴含的性质 当语言的规则不足以保证它表达的任意操作产生的值属于规则事先指定的值的集合之内, 这些规则就不是安全的 安全一般考虑两个方面, 一个是 confidentiality, 一个是 integrity\n未定义行为说成类型不安全其实是符合安全的描述的, 对应 integrity 的 control-flow \u0026 information-flow integrity 类型检查(Typechecking) 现实的类型安全一般通过在语言设计中由两类手段提供支持\n语言的构造性规则限制不安全类型构造的表达 – typing 语言对潜在不安全的表达进行额外的语义检查 – type checking (广义地也能包含typing) 尽管一般实现 typechecking 蕴含解一个判定性问题 – 即作用于代码上判断出一个表示 \"通过\" 或\"不通过\"的二元结果, 却并不一定表示接受或者拒绝接受程序\n一条语言规则不会因为实现要求附加其它行为或不要求任何可预测的行为 (所谓未定义行为) 而不适合归类为 typechecking 规则; 举例: C 的许多使用非兼容类型 (compatible type) 的值的操作是未定义行为, 这不是 typing, 而指定了作用于指针类型上的 typechecking 静态/动态 类型 静态类型或者动态类型都和 typing 的时机有关; 而单纯静态/动态, 对彻底不提供类型系统设计的 typeless 的语言都可能说得通 强类型 强类型 (strong type/strong typing/strongly typed) manifest typing/latent typing ","wordCount":"1123","inLanguage":"en","datePublished":"2023-02-04T22:04:44Z","dateModified":"2023-04-02T00:01:38-07:00","author":{"@type":"Person","name":"ST_Saint"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://st-saint.github.io/posts/typesystem/"},"publisher":{"@type":"Organization","name":"Yayu Wang","logo":{"@type":"ImageObject","url":"https://st-saint.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><header class=header><nav class=nav><div class=logo><a href=https://st-saint.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://st-saint.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://st-saint.github.io/doks title=Docs><span>Docs</span></a></li><li><a href=https://st-saint.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://st-saint.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://st-saint.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://st-saint.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://st-saint.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://st-saint.github.io/posts/>Posts</a></div><h1 class=post-title>Type System</h1><div class=post-meta><span title='2023-04-02 00:01:38 -0700 -0700'>updated < 2023-04-02 Fri 00:01 ></span>&nbsp;·&nbsp;<span title='2023-02-04 22:04:44 +0000 UTC'>publish < 2023-02-04 Fri 22:04 ></span>&nbsp;·&nbsp;ST_Saint&nbsp;|&nbsp;<a href=https://github.com/st-saint/st-saint.github.io/content/posts/TypeSystem.org rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details end><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#headline-1>Terminology</a><ul><li><a href=#headline-2>Judgement</a></li><li><a href=#headline-3>Inference Rules</a><ul><li><a href=#headline-4>Derivation</a><ul><li><a href=#headline-5>Derivation Tree</a></li></ul></li></ul></li><li><a href=#headline-6>Reduction</a></li><li><a href=#headline-7>Substitution</a></li><li><a href=#headline-8>Unification</a></li><li><a href=#headline-9>推导 (deduction)</a></li><li><a href=#headline-10>landin' knot</a></li></ul></li><li><a href=#headline-11>Refinement Types</a><ul><li><a href=#headline-12>Introduction</a><ul><li><a href=#headline-13>passes</a></li></ul></li><li><a href=#headline-14>Simply Typed λ-calculus</a><ul><li><a href=#headline-15>Verification Conditions</a></li><li><a href=#headline-16>arithmetic overflow</a></li></ul></li><li><a href=#headline-17>Branches and Recursion</a></li><li><a href=#headline-18>questions</a><ul><li><a href=#headline-19>Differences between refinement type system and symbolic execution</a></li><li><a href=#headline-20>what would the refinement type system do if the conditions cannot be solved by SMT?</a></li><li><a href=#headline-21>it is a bit confusing that how could you verify termination with a recursion function?</a></li></ul></li></ul></li><li><a href=#headline-22>Sized Types</a><ul><li><a href=#headline-23>productive</a></li><li><a href=#headline-24>Primitive Recursion: Reverse</a><ul><li><a href=#headline-25>Accumulating Parameters</a></li></ul></li><li><a href=#headline-26>Array Bounds Check</a></li><li><a href=#headline-27>questions</a></li></ul></li><li><a href=#headline-28>typing vs typechecking</a><ul><li><a href=#headline-29>本体论(Ontology)</a><ul><li><a href=#headline-30>类型 = 分类？</a></li><li><a href=#headline-31>类型是什么</a></li><li><a href=#headline-32>历史上的类型是什么</a></li><li><a href=#headline-33>类型的意义</a></li></ul></li><li><a href=#headline-34>派生概念</a><ul><li><a href=#headline-35>类型正确(Type Correctness)</a></li><li><a href=#headline-36>类型识别(Type Identification)</a></li><li><a href=#headline-37>类型转换(Type Conversion)</a></li><li><a href=#headline-38>类型安全(Type Safety)</a></li><li><a href=#headline-39>类型检查(Typechecking)</a></li><li><a href=#headline-40>静态/动态 类型</a></li><li><a href=#headline-41>强类型</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Terminology</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Judgement</h3><div id=outline-text-headline-2 class=outline-text-3><ul><li>A judgement is something we may know, that is, an object of knowledge</li><li>A judgement is evident if we in fact know it</li><li>\(e:t\) ⇒ the expression e has type t</li><li><p>\(\Gamma\) ⇒ Context: a set of &lt;variable, type> pairs</p><ul><li>\(\vdash\) ⇒ turnstile</li><li>\(\Gamma \vdash e : t\) ⇒ expression e has type t in the context \(\Gamma\)</li><li>\(\Gamma , x:\tau\) ⇒ extends \(\Gamma\) with knowledge: \(x:\tau\)</li></ul></li></ul></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Inference Rules</h3><div id=outline-text-headline-3 class=outline-text-3><ul><li><p>\(\frac{P1\ P2\ P3\ ...}{C}\)</p><ul><li>C ⇒ conclusion</li><li>P ⇒ premise</li><li>If we konw P1 & P2 & P3 then we know C</li></ul></li></ul><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>Derivation</h4><div id=outline-text-headline-4 class=outline-text-4><blockquote><p>In ML, a typing derivation is a proof that some expression can have some type, given a particular context, not that the expression can only have that type or that the expression will have that type no matter where we encounter it.</p><p>a derivation for ρ ⊢ e : t is a proof that in some context ρ (which assigns types to variables in e), we can show that e can have (at least) the type t, and possibly others.</p></blockquote><ul><li>The one-step evaluation relation → is the smallest binary relation on terms</li><li>When the pair (t , t') is in the evaluation relation, we say that "the evaluation statement (or judgment) t → t' is derivable."</li></ul><div id=outline-container-headline-5 class=outline-5><h5 id=headline-5>Derivation Tree</h5><div id=outline-text-headline-5 class=outline-text-5>\begin{equation}
\notag \large \dfrac{\dfrac{\dfrac{x:Bool \in x: Bool}{x:Bool \vdash x:Bool}}{\vdash \lambda x:Bool . x : Bool \rightarrow Bool} \qquad \dfrac{}{\vdash true: Bool} }{\vdash (\lambda x: Bool.x )\ true: Bool}
\end{equation}
\begin{align*}
x&=\sqrt{b} \\
&=b^{\frac{1}{2}}
\end{align*}</div></div></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Reduction</h3><div id=outline-text-headline-6 class=outline-text-3><ul><li>Also known as <strong>subject evaluation</strong>, <strong>type preservation</strong> or simply <strong>preservation</strong></li></ul><p>$$\frac{\Gamma \vdash e_1:\tau\qquad e_1 \rightarrow e_2}{\Gamma \vdash e_2:\tau}$$</p><p>$$\frac{}{if\ True\ then\ e1\ else\ e2 \rightarrow e1}$$</p><ul><li>$$\frac{e \Downarrow True}{if\ e\ then\ e1\ else\ e2}$$ $${if\ True\ then\ e1\ else\ e2\ \rightarrow\ e1}$$</li></ul></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Substitution</h3><div id=outline-text-headline-7 class=outline-text-3><ul><li>$$e[x \backslash e^a]$$</li></ul><p>$$[x \rightarrow e^{'}]e \Rightarrow [ x \rightarrow e^{'}](let y=e_1\; in\; e_2 ) = let y=[x \rightarrow e^{'}]e_1\; in\; [x \rightarrow e^{'}]e_2 $$</p></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Unification</h3></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>推导 (deduction)</h3></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>landin' knot</h3><div id=outline-text-headline-10 class=outline-text-3><ul><li><p>represent recursion</p><ul><li>13.5.8</li></ul></li></ul></div></div></div></div><div id=outline-container-headline-11 class=outline-2><h2 id=headline-11>Refinement Types</h2><div id=outline-text-headline-11 class=outline-text-2><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>Introduction</h3><div id=outline-text-headline-12 class=outline-text-3><ul><li><p>programs can do things wrong:</p><ol><li>Divided by zero</li><li>Buffer overflow</li><li><p>mismatched dimension</p><ul><li>wrong type casting</li></ul></li><li><p>logic bug</p><ul><li>integer range [min, max]</li></ul></li><li>Correctness error</li></ol></li><li>Refinement type system uses predicates to enrich the type information</li></ul><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>passes</h4><div id=outline-text-headline-13 class=outline-text-4><ol><li>STCL</li><li>branch conditions – path-sensitive</li><li>infer refinements</li><li>type polymorphism – context-sensitive</li><li>polymorphic data types</li><li>refinement polymorphism for different invariants</li><li>verify termination???</li><li>proof proposition over UDF</li></ol></div></div></div></div><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>Simply Typed λ-calculus</h3><div id=outline-text-headline-14 class=outline-text-3><ul><li>primitive constants: <code class=verbatim>nat</code></li><li>primitive operations: <code class=verbatim>add</code></li><li>function type with constrain</li></ul><div id=outline-container-headline-15 class=outline-4><h4 id=headline-15>Verification Conditions</h4><div id=outline-text-headline-15 class=outline-text-4><ul><li>take the annotated program as input and return a VC</li></ul></div></div><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>arithmetic overflow</h4><div id=outline-text-headline-16 class=outline-text-4><ul><li>seems like we can simply add a upper bound (2^31 or 2^63) to avoid overflow here</li></ul></div></div></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>Branches and Recursion</h3><div id=outline-text-headline-17 class=outline-text-3><ul><li>also convert to branches conditions to similar VC</li></ul></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>questions</h3><div id=outline-text-headline-18 class=outline-text-3><div id=outline-container-headline-19 class=outline-4><h4 id=headline-19>Differences between refinement type system and symbolic execution</h4><div id=outline-text-headline-19 class=outline-text-4><ul><li>To formally verify the division by, buffer overflow and integer range problems, refinement type system also add predicates and constrains over variable and use SMT solver to resolve these constrains, so what does refinement types do differently? or actually symbolic execution is one component of refinement type system?</li></ul></div></div><div id=outline-container-headline-20 class=outline-4><h4 id=headline-20>what would the refinement type system do if the conditions cannot be solved by SMT?</h4><div id=outline-text-headline-20 class=outline-text-4><ul><li>if the condition cannot be satisfied, then it should be a logic bug?</li></ul></div></div><div id=outline-container-headline-21 class=outline-4><h4 id=headline-21>it is a bit confusing that how could you verify termination with a recursion function?</h4></div></div></div></div></div><div id=outline-container-headline-22 class=outline-2><h2 id=headline-22>Sized Types</h2><div id=outline-text-headline-22 class=outline-text-2><ul><li>Input makes the program unpredictable. The inputs can taint data or even the control-flow, making memory mess and analysis tricky.</li><li><p>Sized type system is to</p><ul><li>check computation of each stream element terminates.</li><li>express bounds on the sizes of recursive data structures.</li></ul></li></ul><div id=outline-container-headline-23 class=outline-3><h3 id=headline-23>productive</h3><div id=outline-text-headline-23 class=outline-text-3><ul><li>a request for the first <code>i</code> element of the stream is guaranteed to be processed in finite time means the program is productive</li><li>I guess <code class=verbatim>head</code> is to read the first element of a stream and <code class=verbatim>tail</code> is the stream excluding the first element</li><li>so we introduce type: <code>ST^i</code> for streams with at least i elements</li><li>using sized types we can infer the lower bounds on the size of all the streams</li><li>if we can claim a function has a type: <code>ST^i -> ST^j && i>j</code> then we can prove termination</li></ul></div></div><div id=outline-container-headline-24 class=outline-3><h3 id=headline-24>Primitive Recursion: Reverse</h3><div id=outline-text-headline-24 class=outline-text-3><ul><li>sized type system can prove termination or productivity of functions in primitive recursive form</li></ul><div class="src src-lisp"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=nf>reverse</span> <span class=err>::</span> <span class=nv>\forall</span> <span class=nv>i.</span> <span class=nv>\forall</span> <span class=nv>t.</span> <span class=nv>LIST_i</span> <span class=no>t</span> <span class=nv>-&gt;</span> <span class=nv>LIST_i</span> <span class=no>t</span>
</span></span><span class=line><span class=cl><span class=nf>reverse</span> <span class=nv>xs</span> <span class=nf>=</span>
</span></span><span class=line><span class=cl><span class=nb>case</span> <span class=nv>xs</span> <span class=nv>of</span>
</span></span><span class=line><span class=cl><span class=no>Nil</span> <span class=nv>-&gt;</span> <span class=no>Nil</span>
</span></span><span class=line><span class=cl><span class=nv>Cons</span> <span class=nv>y</span> <span class=nv>ys</span> <span class=nv>-&gt;</span> <span class=nf>append</span> <span class=p>(</span><span class=nf>reverse</span> <span class=nv>ys</span><span class=p>)</span> <span class=p>(</span><span class=nv>Cons</span> <span class=nv>y</span> <span class=no>Nil</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div><ol><li><code class=verbatim>Nil -> Nil</code> has type <code>LIST_{i+1} t</code> (why i+t though)</li><li>append (Reverse ys) (Cons y Nil) :: LIST_{<sub>i+1</sub>} -> t</li></ol><div id=outline-container-headline-25 class=outline-4><h4 id=headline-25>Accumulating Parameters</h4><div id=outline-text-headline-25 class=outline-text-4><ul><li>allow a limited form of polymorphic recursion: over sizes, but not types.</li></ul></div></div></div></div><div id=outline-container-headline-26 class=outline-3><h3 id=headline-26>Array Bounds Check</h3><div id=outline-text-headline-26 class=outline-text-3><ul><li><p>We view an array as a function from indices to contents</p><ul><li>an array of t with 6 elements has type <code>NAT_6 -> t</code></li></ul></li></ul></div></div><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>questions</h3><div id=outline-text-headline-27 class=outline-text-3><ul><li>I guess <code>Mk</code> and <code>ST</code> are all special keywords and <code>ST</code> is stream. However I still don't get what how to combine a <code>NAT</code> and a <code>ST</code></li><li>Sized Type consider the length of the stream instead the value of streams. I think the value of input is also important. For example, the Array Bounds Check problem, a common scenario is the array having a dynamic length (i.e. depends on input), and the length becomes unknown to tpye system. So if we want to constrain the input refinement type sounds more reasonable but it will probably become a SAT problem. Even though I feel memory allocation is still a conflict between efficiency and safety. If you allow dynamically length it is more tricky to prove the safety but you gain some flexibility. Is it possible to combine sized type and refinement type to check more security properties of the program?</li></ul></div></div></div></div><div id=outline-container-headline-28 class=outline-2><h2 id=headline-28>typing vs typechecking</h2><div id=outline-text-headline-28 class=outline-text-2><ul><li>顶不住了, 先看看中文文档吧 <a href=https://github.com/FrankHB/pl-docs/blob/master/zh-CN/typing-vs-typechecking.md>typing-vs-typechecking</a></li></ul><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>本体论(Ontology)</h3><div id=outline-text-headline-29 class=outline-text-3><ul><li>类型是一种抽象的实体(entity)</li><li>类型不是名称</li></ul><div id=outline-container-headline-30 class=outline-4><h4 id=headline-30>类型 = 分类？</h4><div id=outline-text-headline-30 class=outline-text-4><ul><li>不是</li><li>不是为了对现有对象"分类", 因为被“分类”的对象都是先前毫无意义, 只是通过这个类型才确定的, 而且具有这样类型的值 <strong>只可能有一种完全等价的</strong> 构造方式, 这就是所谓的 <code>unit type</code> 的实例</li></ul></div></div><div id=outline-container-headline-31 class=outline-4><h4 id=headline-31>类型是什么</h4><div id=outline-text-headline-31 class=outline-text-4><ul><li>对于某个类型系统中的类型——这种人为设计中的一份子</li><li>类型系统的设计者或者类型的设计者（类型系统的用户）希望它是什么</li></ul></div></div><div id=outline-container-headline-32 class=outline-4><h4 id=headline-32>历史上的类型是什么</h4><div id=outline-text-headline-32 class=outline-text-4><ul><li><p><a href=https://zh.wikipedia.org/zh-cn/%E7%BD%97%E7%B4%A0%E6%82%96%E8%AE%BA>罗素悖论</a> - <a href=https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E8%AE%BA>类型论</a></p><ul><li>任给一个性质(例如："年满三十岁"就是一个性质)，满足该性质的所有集合总可以组成一个集合</li><li><p>设有一性质P，并以一性质函数表示：P(x)，且其中的自变量x有此特性： x ∉ x，</p><ul><li>不是, x ∉ x 是什么意思</li></ul></li></ul></li></ul><ul><li>我靠我一直觉得 PL 讲的 type 本质都应该是数学集合, 好像还是有点道理, 然而类型系统好像是集合论的上位(也许)替代</li></ul></div></div><div id=outline-container-headline-33 class=outline-4><h4 id=headline-33>类型的意义</h4><div id=outline-text-headline-33 class=outline-text-4><ul><li>各种类型论中, 并没有要求"类型"成为和某种领域外实体的对应, 以作为建模或"分类"的基础, 而仅仅是项 (term) 上关联的一些抽象实体</li></ul></div></div></div></div><div id=outline-container-headline-34 class=outline-3><h3 id=headline-34>派生概念</h3><div id=outline-text-headline-34 class=outline-text-3><div id=outline-container-headline-35 class=outline-4><h4 id=headline-35>类型正确(Type Correctness)</h4><div id=outline-text-headline-35 class=outline-text-4><ul><li>符合期望</li><li><p>类型是开发者对数据、对实体属性的描述, 显式类型是开发者对于程序设计的理解和限定的直接描述</p><ul><li>原文对可读性和重构的考虑脱离实际</li><li>使用 <code>var</code>, <code>auto</code> 借用 Type inference 省去对数据的描述是让开发者在上下文中丢失对数据的理解, 且不便于第三方审阅代码; 在重构时, 考虑代码改动对数据, 对上下文的影响是非常重要且易错的环节, 显式类型要求开发者对语义的改变进行考虑(当然如果开发者匆匆掠过是另一个问题), 类型推断提供了开发便利但不利于保证程序正确性</li><li>即使使用 <code>var</code>, <code>auto</code> ，一个不可忽视的事实是, 编译器生成的 binary 并不包含 <code>var</code> 类型, 实际 runtime 类型有且只有一个具体类型(如果有 runtime type), 如果没有 runtime type 那么数据就只是纯粹的数据而不带任何限制, 这与源代码中 <code>var</code>, <code>auto</code> 所表达的类型不匹配, 而开发者因代码和运行时的差异对程序行为做出错误预测是非常不理想的设计缺陷</li><li>一个可以接受的选择是type system在编译前就将 <code>auto</code> 替换成具体类型</li></ul></li></ul></div></div><div id=outline-container-headline-36 class=outline-4><h4 id=headline-36>类型识别(Type Identification)</h4><div id=outline-text-headline-36 class=outline-text-4><ul><li>要判断类型是否相同, 比较给定的表示类型的数据结构（类型标识）和已知类型的对应数据结构是否相等</li></ul></div></div><div id=outline-container-headline-37 class=outline-4><h4 id=headline-37>类型转换(Type Conversion)</h4><div id=outline-text-headline-37 class=outline-text-4><ul><li>强制(coercion) 是一种隐式转换</li><li>多态(ad-hoc polymorphsim) 而和铸型(casting) 显式转换</li></ul></div></div><div id=outline-container-headline-38 class=outline-4><h4 id=headline-38>类型安全(Type Safety)</h4><div id=outline-text-headline-38 class=outline-text-4><ul><li><p>较常用的一种安全机制的基本思路是，定义类型是某个域(domain)中值的集合, 保证类型安全即约束需要考察的值总是符合某一些类型的约束.</p><ul><li>判断对象语言描述的程序是否符合类型安全这项任务能被程序表达和实现(包括语言自身的实现, 如编译时的检查).</li><li>这样, 类型安全可以视为某一些语言规则中蕴含的性质</li><li>当语言的规则不足以保证它表达的任意操作产生的值属于规则事先指定的值的集合之内, 这些规则就不是安全的</li></ul></li><li><p>安全一般考虑两个方面, 一个是 confidentiality, 一个是 integrity</p><ul><li>未定义行为说成类型不安全其实是符合安全的描述的, 对应 integrity 的 control-flow & information-flow integrity</li></ul></li></ul></div></div><div id=outline-container-headline-39 class=outline-4><h4 id=headline-39>类型检查(Typechecking)</h4><div id=outline-text-headline-39 class=outline-text-4><ul><li><p>现实的类型安全一般通过在语言设计中由两类手段提供支持</p><ol><li>语言的构造性规则限制不安全类型构造的表达 – typing</li><li>语言对潜在不安全的表达进行额外的语义检查 – type checking (广义地也能包含typing)</li></ol></li><li><p>尽管一般实现 typechecking 蕴含解一个判定性问题 – 即作用于代码上判断出一个表示 "通过" 或"不通过"的二元结果, 却并不一定表示接受或者拒绝接受程序</p><ul><li>一条语言规则不会因为实现要求附加其它行为或不要求任何可预测的行为 (所谓未定义行为) 而不适合归类为 typechecking 规则; 举例: C 的许多使用非兼容类型 (compatible type) 的值的操作是未定义行为, 这不是 typing, 而指定了作用于指针类型上的 typechecking</li></ul></li></ul></div></div><div id=outline-container-headline-40 class=outline-4><h4 id=headline-40>静态/动态 类型</h4><div id=outline-text-headline-40 class=outline-text-4><ul><li>静态类型或者动态类型都和 typing 的时机有关; 而单纯静态/动态, 对彻底不提供类型系统设计的 typeless 的语言都可能说得通</li></ul></div></div><div id=outline-container-headline-41 class=outline-4><h4 id=headline-41>强类型</h4><div id=outline-text-headline-41 class=outline-text-4><ul><li>强类型 (strong type/strong typing/strongly typed)</li><li>manifest typing/latent typing</li></ul></div></div></div></div></div></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://st-saint.github.io/posts/email/><span class=title>« Prev Page</span><br><span>Email</span></a>
<a class=next href=https://st-saint.github.io/posts/kvm/><span class=title>Next Page »</span><br><span>KVM</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Type System on twitter" href="https://twitter.com/intent/tweet/?text=Type%20System&amp;url=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f&amp;hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Type System on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f&amp;title=Type%20System&amp;summary=Type%20System&amp;source=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Type System on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f&title=Type%20System"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Type System on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Type System on whatsapp" href="https://api.whatsapp.com/send?text=Type%20System%20-%20https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Type System on telegram" href="https://telegram.me/share/url?text=Type%20System&amp;url=https%3a%2f%2fst-saint.github.io%2fposts%2ftypesystem%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://st-saint.github.io/>Yayu Wang</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>