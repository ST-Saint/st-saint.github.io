<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Type System - Yayu Wang</title><meta name=Description content="This is my cool site"><meta property="og:title" content="Type System">
<meta property="og:description" content="I don't know what is type system"><meta property="og:type" content="article"><meta property="og:url" content="https://st-saint.github.io/typesystem/"><meta property="og:image" content="https://st-saint.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-04T22:04:44+00:00"><meta property="article:modified_time" content="2023-04-18T11:50:18-07:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://st-saint.github.io/logo.png"><meta name=twitter:title content="Type System"><meta name=twitter:description content="I don't know what is type system"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://st-saint.github.io/typesystem/><link rel=prev href=https://st-saint.github.io/virtualmachine/><link rel=next href=https://st-saint.github.io/email/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Type System","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/st-saint.github.io\/typesystem\/"},"genre":"posts","wordcount":4263,"url":"https:\/\/st-saint.github.io\/typesystem\/","datePublished":"2023-02-04T22:04:44+00:00","dateModified":"2023-04-18T11:50:18-07:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yayu Wang"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yayu Wang"><span class=header-title-pre><i class="nf nf-custom-emacs"></i></span>Home</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=Posts>Posts </a><a class=menu-item href=/archive>Archive </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yayu Wang"><span class=header-title-pre><i class="nf nf-custom-emacs"></i></span>Home</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=Posts>Posts</a><a class=menu-item href=/archive title>Archive</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Type System</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://st-saint.github.io/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Yayu Wang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-02-04>2023-02-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4263 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept=true><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#headline-1>Terminology</a><ul><li><a href=#headline-2>Judgement</a></li><li><a href=#headline-3>Inference Rules</a><ul><li><a href=#headline-4>Derivation</a><ul><li><a href=#headline-5>Derivation Tree</a></li></ul></li></ul></li><li><a href=#headline-6>Reduction</a></li><li><a href=#headline-7>Substitution</a></li><li><a href=#headline-8>Unification</a></li><li><a href=#headline-9>推导 (deduction)</a></li><li><a href=#headline-10>landin' knot</a></li></ul></li><li><a href=#headline-11>Refinement Types</a><ul><li><a href=#headline-12>Introduction</a><ul><li><a href=#headline-13>passes</a></li></ul></li><li><a href=#headline-14>Simply Typed λ-calculus</a><ul><li><a href=#headline-15>Verification Conditions</a></li><li><a href=#headline-16>arithmetic overflow</a></li></ul></li><li><a href=#headline-17>Branches and Recursion</a></li><li><a href=#headline-18>questions</a><ul><li><a href=#headline-19>Differences between refinement type system and symbolic execution</a></li><li><a href=#headline-20>what would the refinement type system do if the conditions cannot be solved by SMT?</a></li><li><a href=#headline-21>it is a bit confusing that how could you verify termination with a recursion function?</a></li></ul></li></ul></li><li><a href=#headline-22>Sized Types</a><ul><li><a href=#headline-23>productive</a></li><li><a href=#headline-24>Primitive Recursion: Reverse</a><ul><li><a href=#headline-25>Accumulating Parameters</a></li></ul></li><li><a href=#headline-26>Array Bounds Check</a></li><li><a href=#headline-27>questions</a></li></ul></li><li><a href=#headline-28>typing vs typechecking</a><ul><li><a href=#headline-29>本体论(Ontology)</a><ul><li><a href=#headline-30>类型 = 分类？</a></li><li><a href=#headline-31>类型是什么</a></li><li><a href=#headline-32>历史上的类型是什么</a></li><li><a href=#headline-33>类型的意义</a></li></ul></li><li><a href=#headline-34>派生概念</a><ul><li><a href=#headline-35>类型正确(Type Correctness)</a></li><li><a href=#headline-36>类型识别(Type Identification)</a></li><li><a href=#headline-37>类型转换(Type Conversion)</a></li><li><a href=#headline-38>类型安全(Type Safety)</a></li><li><a href=#headline-39>类型检查(Typechecking)</a></li><li><a href=#headline-40>静态/动态 类型</a></li><li><a href=#headline-41>强类型</a></li></ul></li></ul></li><li><a href=#headline-42>Dependent typing</a><ul><li><a href=#headline-43>Formal definition</a><ul><li><a href=#headline-44>Π type</a></li><li><a href=#headline-45>Σ type</a></li></ul></li><li><a href=#headline-46>Extra reading</a><ul><li><a href=#headline-47>Extensional and intensional definitions</a><ul><li><a href=#headline-48>Intensional definition</a></li><li><a href=#headline-49>Extensional definition</a></li></ul></li><li><a href=#headline-50>intuitionistic logic</a></li><li><a href=#headline-51>First-order logic</a></li><li><a href=#headline-52>Curry–Howard correspondence</a><ul><li><a href=#headline-53>General formulation</a></li><li><a href=#headline-54>Hilbert-style deduction systems</a><ul><li><a href=#headline-55>axiom schemes</a></li><li><a href=#headline-56>formalization</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#headline-57>From System F to Typed Assembly Language</a><ul><li><a href=#headline-58>abstract</a><ul><li><a href=#headline-59>question</a></li></ul></li><li><a href=#headline-60>introduction</a><ul><li><a href=#headline-61>SPIN</a></li></ul></li><li><a href=#headline-62>overview</a><ul><li><a href=#headline-63>TAL</a></li><li><a href=#headline-64>type-preserving compiler</a><ul><li><a href=#headline-65>workflow</a></li></ul></li></ul></li><li><a href=#headline-66>System-F</a></li><li><a href=#headline-67>CPS</a></li><li><a href=#headline-68>λ^K</a><ul><li><a href=#headline-69>Translation</a></li></ul></li><li><a href=#headline-70>Simplified polymorphic closure conversion</a><ul><li><a href=#headline-71>Translation</a></li><li><a href=#headline-72>Hoisting</a></li></ul></li><li><a href=#headline-73>Explicit allocation</a><ul><li><a href=#headline-74>Translation</a></li></ul></li><li><a href=#headline-75>Typed Assembly language</a><ul><li><a href=#headline-76>TAL syntax</a></li><li><a href=#headline-77>TAL Operational Semantics</a></li><li><a href=#headline-78>TAL Static Semantics</a></li><li><a href=#headline-79>Code generation</a></li></ul></li><li><a href=#headline-80>Optimization</a></li></ul></li></ul></nav></div></div><div class=content id=content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Terminology</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Judgement</h3><div id=outline-text-headline-2 class=outline-text-3><ul><li>A judgement is something we may know, that is, an object of knowledge</li><li>A judgement is evident if we in fact know it</li><li>\(e:t\) ⇒ the expression e has type t</li><li><p>\(\Gamma\) ⇒ Context: a set of &lt;variable, type> pairs</p><ul><li>\(\vdash\) ⇒ turnstile</li><li>\(\Gamma \vdash e : t\) ⇒ expression e has type t in the context \(\Gamma\)</li><li>\(\Gamma , x:\tau\) ⇒ extends \(\Gamma\) with knowledge: \(x:\tau\)</li></ul></li></ul></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Inference Rules</h3><div id=outline-text-headline-3 class=outline-text-3><ul><li><p>\(\frac{P1\ P2\ P3\ ...}{C}\)</p><ul><li>C ⇒ conclusion</li><li>P ⇒ premise</li><li>If we konw P1 & P2 & P3 then we know C</li></ul></li></ul><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>Derivation</h4><div id=outline-text-headline-4 class=outline-text-4><blockquote><p>In ML, a typing derivation is a proof that some expression can have some type, given a particular context, not that the expression can only have that type or that the expression will have that type no matter where we encounter it.</p><p>a derivation for ρ ⊢ e : t is a proof that in some context ρ (which assigns types to variables in e), we can show that e can have (at least) the type t, and possibly others.</p></blockquote><ul><li>The one-step evaluation relation → is the smallest binary relation on terms</li><li>When the pair (t , t') is in the evaluation relation, we say that "the evaluation statement (or judgment) t → t' is derivable."</li></ul><div id=outline-container-headline-5 class=outline-5><h5 id=headline-5>Derivation Tree</h5><div id=outline-text-headline-5 class=outline-text-5>\begin{equation}
\notag \large \dfrac{\dfrac{\dfrac{x:Bool \in x: Bool}{x:Bool \vdash x:Bool}}{\vdash \lambda x:Bool . x : Bool \rightarrow Bool} \qquad \dfrac{}{\vdash true: Bool} }{\vdash (\lambda x: Bool.x )\ true: Bool}
\end{equation}</div></div></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Reduction</h3><div id=outline-text-headline-6 class=outline-text-3><ul><li><p>Also known as <strong>subject evaluation</strong>, <strong>type preservation</strong> or simply <strong>preservation</strong></p><ol><li>$$\frac{\Gamma \vdash e_1:\tau\qquad e_1 \rightarrow e_2}{\Gamma \vdash e_2:\tau}$$</li><li>$$\frac{}{if\ True\ then\ e1\ else\ e2 \rightarrow e1}$$</li><li>$$\frac{e \Downarrow True}{if\ e\ then\ e1\ else\ e2}$$ $${if\ True\ then\ e1\ else\ e2\ \rightarrow\ e1}$$</li></ol></li></ul></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Substitution</h3><div id=outline-text-headline-7 class=outline-text-3><ul><li>$$[x \rightarrow s]x = s$$</li><li>$$e[x \backslash e^a] == [ x \rightarrow e^a] e$$</li></ul>\begin{align}
& [ x \rightarrow e^{'}](let y=e_1\; in\; e_2 ) \\
= & let y = [x \rightarrow e^{'}]e_1\; in\; [x \rightarrow e^{'}]e_2
\end{align}</div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Unification</h3></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>推导 (deduction)</h3></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>landin' knot</h3><div id=outline-text-headline-10 class=outline-text-3><ul><li><p>represent recursion</p><ul><li>13.5.8</li></ul></li></ul></div></div></div></div><div id=outline-container-headline-11 class=outline-2><h2 id=headline-11>Refinement Types</h2><div id=outline-text-headline-11 class=outline-text-2><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>Introduction</h3><div id=outline-text-headline-12 class=outline-text-3><ul><li><p>programs can do things wrong:</p><ol><li>Divided by zero</li><li>Buffer overflow</li><li><p>mismatched dimension</p><ul><li>wrong type casting</li></ul></li><li><p>logic bug</p><ul><li>integer range [min, max]</li></ul></li><li>Correctness error</li></ol></li><li>Refinement type system uses predicates to enrich the type information</li></ul><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>passes</h4><div id=outline-text-headline-13 class=outline-text-4><ol><li>STCL</li><li>branch conditions – path-sensitive</li><li>infer refinements</li><li>type polymorphism – context-sensitive</li><li>polymorphic data types</li><li>refinement polymorphism for different invariants</li><li>verify termination???</li><li>proof proposition over UDF</li></ol></div></div></div></div><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>Simply Typed λ-calculus</h3><div id=outline-text-headline-14 class=outline-text-3><ul><li>primitive constants: <code class=verbatim>nat</code></li><li>primitive operations: <code class=verbatim>add</code></li><li>function type with constrain</li></ul><div id=outline-container-headline-15 class=outline-4><h4 id=headline-15>Verification Conditions</h4><div id=outline-text-headline-15 class=outline-text-4><ul><li>take the annotated program as input and return a VC</li></ul></div></div><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>arithmetic overflow</h4><div id=outline-text-headline-16 class=outline-text-4><ul><li>seems like we can simply add a upper bound (2^31 or 2^63) to avoid overflow here</li></ul></div></div></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>Branches and Recursion</h3><div id=outline-text-headline-17 class=outline-text-3><ul><li>also convert to branches conditions to similar VC</li></ul></div></div><div id=outline-container-headline-18 class=outline-3><h3 id=headline-18>questions</h3><div id=outline-text-headline-18 class=outline-text-3><div id=outline-container-headline-19 class=outline-4><h4 id=headline-19>Differences between refinement type system and symbolic execution</h4><div id=outline-text-headline-19 class=outline-text-4><ul><li>To formally verify the division by, buffer overflow and integer range problems, refinement type system also add predicates and constrains over variable and use SMT solver to resolve these constrains, so what does refinement types do differently? or actually symbolic execution is one component of refinement type system?</li></ul></div></div><div id=outline-container-headline-20 class=outline-4><h4 id=headline-20>what would the refinement type system do if the conditions cannot be solved by SMT?</h4><div id=outline-text-headline-20 class=outline-text-4><ul><li>if the condition cannot be satisfied, then it should be a logic bug?</li></ul></div></div><div id=outline-container-headline-21 class=outline-4><h4 id=headline-21>it is a bit confusing that how could you verify termination with a recursion function?</h4></div></div></div></div></div><div id=outline-container-headline-22 class=outline-2><h2 id=headline-22>Sized Types</h2><div id=outline-text-headline-22 class=outline-text-2><ul><li>Input makes the program unpredictable. The inputs can taint data or even the control-flow, making memory mess and analysis tricky.</li><li><p>Sized type system is to</p><ul><li>check computation of each stream element terminates.</li><li>express bounds on the sizes of recursive data structures.</li></ul></li></ul><div id=outline-container-headline-23 class=outline-3><h3 id=headline-23>productive</h3><div id=outline-text-headline-23 class=outline-text-3><ul><li>a request for the first <code>i</code> element of the stream is guaranteed to be processed in finite time means the program is productive</li><li>I guess <code class=verbatim>head</code> is to read the first element of a stream and <code class=verbatim>tail</code> is the stream excluding the first element</li><li>so we introduce type: <code>ST^i</code> for streams with at least i elements</li><li>using sized types we can infer the lower bounds on the size of all the streams</li><li>if we can claim a function has a type: <code>ST^i -> ST^j && i>j</code> then we can prove termination</li></ul></div></div><div id=outline-container-headline-24 class=outline-3><h3 id=headline-24>Primitive Recursion: Reverse</h3><div id=outline-text-headline-24 class=outline-text-3><ul><li>sized type system can prove termination or productivity of functions in primitive recursive form</li></ul><div class="src src-lisp"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=nf>reverse</span> <span class=err>::</span> <span class=nv>\forall</span> <span class=nv>i.</span> <span class=nv>\forall</span> <span class=nv>t.</span> <span class=nv>LIST_i</span> <span class=no>t</span> <span class=nv>-&gt;</span> <span class=nv>LIST_i</span> <span class=no>t</span>
</span></span><span class=line><span class=cl><span class=nf>reverse</span> <span class=nv>xs</span> <span class=nf>=</span>
</span></span><span class=line><span class=cl><span class=nb>case</span> <span class=nv>xs</span> <span class=nv>of</span>
</span></span><span class=line><span class=cl><span class=no>Nil</span> <span class=nv>-&gt;</span> <span class=no>Nil</span>
</span></span><span class=line><span class=cl><span class=nv>Cons</span> <span class=nv>y</span> <span class=nv>ys</span> <span class=nv>-&gt;</span> <span class=nf>append</span> <span class=p>(</span><span class=nf>reverse</span> <span class=nv>ys</span><span class=p>)</span> <span class=p>(</span><span class=nv>Cons</span> <span class=nv>y</span> <span class=no>Nil</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div><ol><li><code class=verbatim>Nil -> Nil</code> has type <code>LIST_{i+1} t</code> (why i+t though)</li><li>append (Reverse ys) (Cons y Nil) :: LIST_{<sub>i+1</sub>} -> t</li></ol><div id=outline-container-headline-25 class=outline-4><h4 id=headline-25>Accumulating Parameters</h4><div id=outline-text-headline-25 class=outline-text-4><ul><li>allow a limited form of polymorphic recursion: over sizes, but not types.</li></ul></div></div></div></div><div id=outline-container-headline-26 class=outline-3><h3 id=headline-26>Array Bounds Check</h3><div id=outline-text-headline-26 class=outline-text-3><ul><li><p>We view an array as a function from indices to contents</p><ul><li>an array of t with 6 elements has type <code>NAT_6 -> t</code></li></ul></li></ul></div></div><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>questions</h3><div id=outline-text-headline-27 class=outline-text-3><ul><li>I guess <code>Mk</code> and <code>ST</code> are all special keywords and <code>ST</code> is stream. However I still don't get what how to combine a <code>NAT</code> and a <code>ST</code></li><li>Sized Type consider the length of the stream instead the value of streams. I think the value of input is also important. For example, the Array Bounds Check problem, a common scenario is the array having a dynamic length (i.e. depends on input), and the length becomes unknown to tpye system. So if we want to constrain the input refinement type sounds more reasonable but it will probably become a SAT problem. Even though I feel memory allocation is still a conflict between efficiency and safety. If you allow dynamically length it is more tricky to prove the safety but you gain some flexibility. Is it possible to combine sized type and refinement type to check more security properties of the program?</li></ul></div></div></div></div><div id=outline-container-headline-28 class=outline-2><h2 id=headline-28>typing vs typechecking</h2><div id=outline-text-headline-28 class=outline-text-2><ul><li>顶不住了, 先看看中文文档吧 <a href=https://github.com/FrankHB/pl-docs/blob/master/zh-CN/typing-vs-typechecking.md>typing-vs-typechecking</a></li></ul><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>本体论(Ontology)</h3><div id=outline-text-headline-29 class=outline-text-3><ul><li>类型是一种抽象的实体(entity)</li><li>类型不是名称</li></ul><div id=outline-container-headline-30 class=outline-4><h4 id=headline-30>类型 = 分类？</h4><div id=outline-text-headline-30 class=outline-text-4><ul><li>不是</li><li>不是为了对现有对象"分类", 因为被“分类”的对象都是先前毫无意义, 只是通过这个类型才确定的, 而且具有这样类型的值 <strong>只可能有一种完全等价的</strong> 构造方式, 这就是所谓的 <code>unit type</code> 的实例</li></ul></div></div><div id=outline-container-headline-31 class=outline-4><h4 id=headline-31>类型是什么</h4><div id=outline-text-headline-31 class=outline-text-4><ul><li>对于某个类型系统中的类型——这种人为设计中的一份子</li><li>类型系统的设计者或者类型的设计者（类型系统的用户）希望它是什么</li></ul></div></div><div id=outline-container-headline-32 class=outline-4><h4 id=headline-32>历史上的类型是什么</h4><div id=outline-text-headline-32 class=outline-text-4><ul><li><p><a href=https://zh.wikipedia.org/zh-cn/%E7%BD%97%E7%B4%A0%E6%82%96%E8%AE%BA>罗素悖论</a> - <a href=https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E8%AE%BA>类型论</a></p><ul><li>任给一个性质(例如："年满三十岁"就是一个性质)，满足该性质的所有集合总可以组成一个集合</li><li><p>设有一性质P，并以一性质函数表示：P(x)，且其中的自变量x有此特性： x ∉ x，</p><ul><li>不是, x ∉ x 是什么意思</li></ul></li></ul></li><li>我靠我一直觉得 PL 讲的 type 本质都应该是数学集合, 好像还是有点道理, 然而类型系统好像是集合论的上位(也许)替代</li></ul></div></div><div id=outline-container-headline-33 class=outline-4><h4 id=headline-33>类型的意义</h4><div id=outline-text-headline-33 class=outline-text-4><ul><li>各种类型论中, 并没有要求"类型"成为和某种领域外实体的对应, 以作为建模或"分类"的基础, 而仅仅是项 (term) 上关联的一些抽象实体</li></ul></div></div></div></div><div id=outline-container-headline-34 class=outline-3><h3 id=headline-34>派生概念</h3><div id=outline-text-headline-34 class=outline-text-3><div id=outline-container-headline-35 class=outline-4><h4 id=headline-35>类型正确(Type Correctness)</h4><div id=outline-text-headline-35 class=outline-text-4><ul><li>符合期望</li><li><p>类型是开发者对数据、对实体属性的描述, 显式类型是开发者对于程序设计的理解和限定的直接描述</p><ul><li>原文对可读性和重构的考虑脱离实际</li><li>使用 <code>var</code>, <code>auto</code> 借用 Type inference 省去对数据的描述是让开发者在上下文中丢失对数据的理解, 且不便于第三方审阅代码; 在重构时, 考虑代码改动对数据, 对上下文的影响是非常重要且易错的环节, 显式类型要求开发者对语义的改变进行考虑(当然如果开发者匆匆掠过是另一个问题), 类型推断提供了开发便利但不利于保证程序正确性</li><li>即使使用 <code>var</code>, <code>auto</code> ，一个不可忽视的事实是, 编译器生成的 binary 并不包含 <code>var</code> 类型, 实际 runtime 类型有且只有一个具体类型(如果有 runtime type), 如果没有 runtime type 那么数据就只是纯粹的数据而不带任何限制, 这与源代码中 <code>var</code>, <code>auto</code> 所表达的类型不匹配, 而开发者因代码和运行时的差异对程序行为做出错误预测是非常不理想的设计缺陷</li><li>一个可以接受的选择是type system在编译前就将 <code>auto</code> 替换成具体类型</li></ul></li></ul></div></div><div id=outline-container-headline-36 class=outline-4><h4 id=headline-36>类型识别(Type Identification)</h4><div id=outline-text-headline-36 class=outline-text-4><ul><li>要判断类型是否相同, 比较给定的表示类型的数据结构（类型标识）和已知类型的对应数据结构是否相等</li></ul></div></div><div id=outline-container-headline-37 class=outline-4><h4 id=headline-37>类型转换(Type Conversion)</h4><div id=outline-text-headline-37 class=outline-text-4><ul><li>强制(coercion) 是一种隐式转换</li><li>多态(ad-hoc polymorphism) 而和铸型(casting) 显式转换</li></ul></div></div><div id=outline-container-headline-38 class=outline-4><h4 id=headline-38>类型安全(Type Safety)</h4><div id=outline-text-headline-38 class=outline-text-4><ul><li><p>较常用的一种安全机制的基本思路是，定义类型是某个域(domain)中值的集合, 保证类型安全需要考察的值是否总是符合其对应类型的约束.</p><ul><li>判断对象语言描述的程序是否符合类型安全这项任务能被程序表达和实现(包括语言自身的实现, 如编译时的检查).</li><li>这样, 类型安全可以视为某一些语言规则中蕴含的性质</li><li>当语言的规则不足以保证它表达的任意操作产生的值属于规则事先指定的值的集合之内, 这些规则就不是安全的</li></ul></li><li><p>安全一般考虑两个方面, 一个是 confidentiality, 一个是 integrity</p><ul><li>未定义行为说成类型不安全其实是符合安全的描述的, 对应 integrity 的 control-flow & information-flow integrity</li></ul></li></ul></div></div><div id=outline-container-headline-39 class=outline-4><h4 id=headline-39>类型检查(Typechecking)</h4><div id=outline-text-headline-39 class=outline-text-4><ul><li><p>现实的类型安全一般通过在语言设计中由两类手段提供支持</p><ol><li>语言的构造性规则限制不安全类型构造的表达 – typing</li><li>语言对潜在不安全的表达进行额外的语义检查 – type checking (广义地也能包含typing)</li></ol></li><li><p>尽管一般实现 typechecking 蕴含解一个判定性问题 – 即作用于代码上判断出一个表示 "通过" 或"不通过"的二元结果, 却并不一定表示接受或者拒绝接受程序</p><ul><li>一条语言规则不会因为实现要求附加其它行为或不要求任何可预测的行为 (所谓未定义行为) 而不适合归类为 typechecking 规则; 举例: C 的许多使用非兼容类型 (compatible type) 的值的操作是未定义行为, 这不是 typing, 而指定了作用于指针类型上的 typechecking</li></ul></li></ul></div></div><div id=outline-container-headline-40 class=outline-4><h4 id=headline-40>静态/动态 类型</h4><div id=outline-text-headline-40 class=outline-text-4><ul><li>静态类型或者动态类型都和 typing 的时机有关; 而单纯静态/动态, 对彻底不提供类型系统设计的 typeless 的语言都可能说得通</li></ul></div></div><div id=outline-container-headline-41 class=outline-4><h4 id=headline-41>强类型</h4><div id=outline-text-headline-41 class=outline-text-4><ul><li>强类型 (strong type/strong typing/strongly typed)</li><li>manifest typing/latent typing</li></ul></div></div></div></div></div></div><div id=outline-container-headline-42 class=outline-2><h2 id=headline-42>Dependent typing</h2><div id=outline-text-headline-42 class=outline-text-2><ul><li>a dependent type is a type whose definition depends on a value</li><li><p>dependent types are used to encode logic's quantifiers like "for all" and "there exists"</p></li></ul><ul><li><p>Two common examples of dependent types are dependent functions, which correspond to "for all" and dependent pairs, which correspond to "there exists". The return type of a dependent function may depend on the value (not just type) of one of its arguments.</p></li><li><p>Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result</p><ul><li>the decidability of type checking may depend on the given type theory's semantics of equality, that is, whether the type theory is intensional or extensional.</li></ul></li></ul><div id=outline-container-headline-43 class=outline-3><h3 id=headline-43>Formal definition</h3><div id=outline-text-headline-43 class=outline-text-3><div id=outline-container-headline-44 class=outline-4><h4 id=headline-44>Π type</h4><div id=outline-text-headline-44 class=outline-text-4><ul><li>dependent types are similar to the type of an indexed family of sets</li><li>formally, given a type <code>A: U</code> in a universe of types <code>U</code>, one may have a family of types <code>B: A \to U</code>, which assigns to each term <code>a: A</code> a type <code>B(a): U</code>. We say that the type <code>B(a)</code> varies with <code>a</code>.</li><li><p>A function whose type of return value varies with its argument (i.e. there is no fixed codomain) is a dependent function and the type of this function is called dependent product type, pi-type (Π type) or dependent function type.</p><ul><li>Written as <code>\Pi_{(x:A)} B(x)</code></li></ul></li></ul></div></div><div id=outline-container-headline-45 class=outline-4><h4 id=headline-45>Σ type</h4><div id=outline-text-headline-45 class=outline-text-4><ul><li>The dual of the dependent product type is the dependent pair type, dependent sum type, sigma-type</li><li>If, in the universe of types <code>U</code>, there is a type <code>A: U</code> and a family of types <code>B: A \to U</code>, then there is a dependent pair type <code>\sum_{x:A} B(x)</code></li><li>The dependent pair type captures the idea of an ordered pair where the type of the second term is dependent on the value of the first. If <code>(a,b):\sum_{x:A}B(x)</code> then <code>a: A</code> and <code>b: B(a)</code></li></ul></div></div></div></div><div id=outline-container-headline-46 class=outline-3><h3 id=headline-46>Extra reading</h3><div id=outline-text-headline-46 class=outline-text-3><div id=outline-container-headline-47 class=outline-4><h4 id=headline-47>Extensional and intensional definitions</h4><div id=outline-text-headline-47 class=outline-text-4><div id=outline-container-headline-48 class=outline-5><h5 id=headline-48>Intensional definition</h5><div id=outline-text-headline-48 class=outline-text-5><ul><li>An intensional definition gives meaning to a term by specifying necessary and sufficient conditions for when the term should be used.</li><li>intensional definitions are best used when something has a clearly defined set of properties, and they work well for terms that have too many referents to list in an extensional definition.</li></ul></div></div><div id=outline-container-headline-49 class=outline-5><h5 id=headline-49>Extensional definition</h5><div id=outline-text-headline-49 class=outline-text-5><ul><li>An extensional definition gives meaning to a term by specifying its extension, that is, every object that falls under the definition of the term in question.</li><li>An explicit listing of the extension, which is only possible for finite sets and only practical for relatively small sets, is a type of enumerative definition.</li><li>Extensional definitions are used when listing examples would give more applicable information than other types of definition, and where listing the members of a set tells the questioner enough about the nature of that set.</li></ul><blockquote><p>A fundamental distinction is extensional vs intensional type theory. In extensional type theory, definitional (i.e., computational) equality is not distinguished from propositional equality, which requires proof. As a consequence type checking becomes undecidable in extensional type theory because programs in the theory might not terminate. For example, such a theory allows one to give a type to the Y-combinator; a detailed example of this can be found in Nordstöm and Petersson Programming in Martin-Löf's Type Theory.[2] However, this does not prevent extensional type theory from being a basis for a practical tool; for example, NuPRL is based on extensional type theory.</p></blockquote></div></div></div></div><div id=outline-container-headline-50 class=outline-4><h4 id=headline-50>intuitionistic logic</h4><div id=outline-text-headline-50 class=outline-text-4><ul><li><p>In the semantics of classical logic, propositional formulae are assigned truth values from the two-element set <code>\top, \bot</code> ("true" and "false" respectively)</p><ul><li>This is referred to as the 'law of excluded middle', because it excludes the possibility of any truth value besides 'true' or 'false'</li></ul></li><li>Propositional formulae in intuitionistic logic are not assigned a definite truth value and are only considered "true" when we have direct evidence, hence proof.</li><li>if there is a constructive proof that an object exists, that constructive proof may be used as an algorithm for generating an example of that object, a principle known as the Curry–Howard correspondence between proofs and algorithms.</li><li>the double negation of the law is retained as a tautology of the system: that is, it is a theorem that <code>\neg(\neg (P \vee \neg P))</code> regardless of the proposition <code>P</code></li><li>In intuitionistic logic, only <code>P \rightarrow \neg\neg P</code> is theorem, <code>\neg\neg P \rightarrow P</code> is not</li></ul></div></div><div id=outline-container-headline-51 class=outline-4><h4 id=headline-51>First-order logic</h4><div id=outline-text-headline-51 class=outline-text-4><ul><li>First-order logic—also known as predicate logic, quantificational logic, and first-order predicate calculus</li><li>Predicate logic is an extension of propositional logic, adding quantifiers.</li></ul></div></div><div id=outline-container-headline-52 class=outline-4><h4 id=headline-52>Curry–Howard correspondence</h4><div id=outline-text-headline-52 class=outline-text-4><ul><li><p>Curry–Howard correspondence (also known as the Curry–Howard isomorphism or equivalence) is the direct relationship between computer programs and mathematical proofs.</p><ul><li>A proof is a program, and the formula it proves is the type for the program</li></ul></li></ul><div id=outline-container-headline-53 class=outline-5><h5 id=headline-53>General formulation</h5><div id=outline-text-headline-53 class=outline-text-5><table><tbody><tr><td>Logic side</td><td>Programming side</td></tr><tr><td>universal quantification</td><td>generalised product type (Π type)</td></tr><tr><td>existential</td><td>quantification generalised sum type (Σ type)</td></tr><tr><td>implication</td><td>function type</td></tr><tr><td>conjunction</td><td>product type</td></tr><tr><td>disjunction</td><td>sum type</td></tr><tr><td>true formula</td><td>unit type or top type</td></tr><tr><td>false formula</td><td>empty type or bottom type</td></tr><tr><td>hypotheses</td><td>free variables</td></tr><tr><td>implication elimination (modus ponens)</td><td>application</td></tr><tr><td>implication introduction</td><td>abstraction</td></tr><tr><td>assumption</td><td>variable</td></tr><tr><td>axiom schemes</td><td>combinators</td></tr><tr><td>modus ponens</td><td>application</td></tr><tr><td>deduction theorem</td><td>abstraction elimination</td></tr></tbody></table></div></div><div id=outline-container-headline-54 class=outline-5><h5 id=headline-54>Hilbert-style deduction systems</h5><div id=outline-text-headline-54 class=outline-text-5><div id=outline-container-headline-55 class=outline-6><h6 id=headline-55>axiom schemes</h6><div id=outline-text-headline-55 class=outline-text-6><ol><li><p>α → (β → α)</p><ol><li>K: λ xy.x</li></ol></li><li><p>(α → (β → γ)) → ((α → β) → (α → γ))</p><ol><li>S: λ xyz.(x z (y z))</li></ol></li></ol></div></div><div id=outline-container-headline-56 class=outline-6><h6 id=headline-56>formalization</h6><div id=outline-text-headline-56 class=outline-text-6><ul><li><p>Let Γ be a finite collection of formulas, considered as hypotheses. Then δ is derivable from Γ, denoted Γ ⊢ δ, in the following cases:</p><ol><li>δ is an hypothesis, i.e. it is a formula of Γ,</li><li><p>δ is an instance of an axiom scheme; i.e., under the most common axiom system:</p><ol><li>δ has the form α → (β → α), or</li><li>δ has the form (α → (β → γ)) → ((α → β) → (α → γ)),</li></ol></li><li>δ follows by deduction, i.e., for some α, both α → δ and α are already derivable from Γ (this is the rule of modus ponens)</li></ol></li></ul></div></div></div></div></div></div></div></div></div></div><div id=outline-container-headline-57 class=outline-2><h2 id=headline-57>From System F to Typed Assembly Language</h2><div id=outline-text-headline-57 class=outline-text-2><div id=outline-container-headline-58 class=outline-3><h3 id=headline-58>abstract</h3><div id=outline-text-headline-58 class=outline-text-3><ul><li>type-preserving transformation from the System-F to Typed Assembly Language (TAL)</li><li>admit low-level compiler optimization</li><li>CPS & A polymorphic closure conversion phases</li><li>Get type-correct source program and map it to type-correct ASM</li><li>Compiler</li></ul><div id=outline-container-headline-59 class=outline-4><h4 id=headline-59>question</h4><div id=outline-text-headline-59 class=outline-text-4><ul><li><span style=text-decoration:underline>suitable for use in systems where untrusted and potentially malicious code must be checked for safety before execution.</span> but in untrusted environment usually we could only access binary without source code</li><li>CPS conversion, closure conversion, unboxing, subsumption elimination, or region inference</li></ul></div></div></div></div><div id=outline-container-headline-60 class=outline-3><h3 id=headline-60>introduction</h3><div id=outline-text-headline-60 class=outline-text-3><ul><li>some type information are lost</li><li><p>admits most conventional low-level optimizations such as</p><ol><li>global register allocation</li><li>copy propagation</li><li>constant folding</li><li>dead-code elimination.</li></ol></li><li class=unchecked><span style=text-decoration:underline>Except for a small number of atomic code patterns</span>. What patterns?</li><li><p>support code motion</p><ol><li>instruction scheduling</li><li>common-subexpression</li><li>elimination</li><li>loop-invariant removal</li></ol></li><li><p>not support</p><ol><li>run-time code generation</li><li>intensional polymorphism</li><li>array bounds check elimination</li></ol></li></ul><div id=outline-container-headline-61 class=outline-4><h4 id=headline-61>SPIN</h4><div id=outline-text-headline-61 class=outline-text-4><ul><li>type-check in Linux kernel</li></ul></div></div></div></div><div id=outline-container-headline-62 class=outline-3><h3 id=headline-62>overview</h3><div id=outline-text-headline-62 class=outline-text-3><div id=outline-container-headline-63 class=outline-4><h4 id=headline-63>TAL</h4></div><div id=outline-container-headline-64 class=outline-4><h4 id=headline-64>type-preserving compiler</h4><div id=outline-text-headline-64 class=outline-text-4><div id=outline-container-headline-65 class=outline-5><h5 id=headline-65>workflow</h5><div id=outline-text-headline-65 class=outline-text-5><ol><li>λ^F -> CPS conversion</li><li>λ^k -> Closure conversion</li><li>λ^C -> Hoisting</li><li>λ^H -> Allocation</li><li>λ^A -> Code Generation</li></ol></div></div></div></div></div></div><div id=outline-container-headline-66 class=outline-3><h3 id=headline-66>System-F</h3><div id=outline-text-headline-66 class=outline-text-3><ul><li>polymorphic λ-calculus</li></ul></div></div><div id=outline-container-headline-67 class=outline-3><h3 id=headline-67>CPS</h3><div id=outline-text-headline-67 class=outline-text-3><ul><li>continuation passnig style – eliminates the need for a control stack</li><li>all unconditional control transfer: function invocation and return are achieved via function call.</li></ul></div></div><div id=outline-container-headline-68 class=outline-3><h3 id=headline-68>λ^K</h3><div id=outline-text-headline-68 class=outline-text-3><ul><li>λ^K consists of a series of let bindings followed by a function call</li><li>only one abstraction for both type and value variables</li><li class=unchecked>halt?</li><li>functions do not return values but it just jumps</li><li>expression never return values</li><li>∆; Γ ⊢_K e indicates that the term e is well formed</li></ul><div id=outline-container-headline-69 class=outline-4><h4 id=headline-69>Translation</h4><div id=outline-text-headline-69 class=outline-text-4><ul><li><code>K_exp 〚 e 〛</code> takes a continuation k, computes the value of e and hands that value to k</li><li class=unchecked>variable capture?</li><li class=unchecked>can all STLC be transformed into CPS?</li><li>a realistic CPS-converter would eliminate "administrative" redices and optimize tail recursion</li></ul></div></div></div></div><div id=outline-container-headline-70 class=outline-3><h3 id=headline-70>Simplified polymorphic closure conversion</h3><div id=outline-text-headline-70 class=outline-text-3><ul><li><p>Making closure explicit and therby separating program code from data</p><ol><li class=unchecked><p>rewrite functions so that there is no free varaibles. how?</p><ol><li>function calls are performed by calling code with the environment as an addtional argument</li></ol></li><li>hoisting: lift the code blocks to the top of the program</li><li>adopt the type-erasure interpretation of polymorphism which substitude the free type variables directly into code blocks</li></ol></li></ul><div id=outline-container-headline-71 class=outline-4><h4 id=headline-71>Translation</h4><div id=outline-text-headline-71 class=outline-text-4><ul><li><code>C〚·〛</code>: β represent the type of the value environment for the closure</li></ul></div></div><div id=outline-container-headline-72 class=outline-4><h4 id=headline-72>Hoisting</h4><div id=outline-text-headline-72 class=outline-text-4><ul><li><code class=verbatim>fix</code> is no longer a value form.</li><li>code blocks are defined by <code class=verbatim>letrec</code> prefix</li><li class=unchecked><code class=verbatim>letrec</code> and mutually recursive and CPS?</li></ul></div></div></div></div><div id=outline-container-headline-73 class=outline-3><h3 id=headline-73>Explicit allocation</h3><div id=outline-text-headline-73 class=outline-text-3><ul><li>eliminate the value form for tuples</li><li><p>introduce new declaration forms for allocating and initializing tuples</p><ul><li>n-element tuple can be separated into an allocation and n initialization</li></ul></li></ul><div id=outline-container-headline-74 class=outline-4><h4 id=headline-74>Translation</h4><div id=outline-text-headline-74 class=outline-text-4><ul><li class=unchecked>memory layout of nested structure?</li></ul></div></div></div></div><div id=outline-container-headline-75 class=outline-3><h3 id=headline-75>Typed Assembly language</h3><div id=outline-text-headline-75 class=outline-text-3><ul><li><p>simultaneously abstract</p><ol><li>a type environment</li><li>a set of type arguments</li><li>a set of value arguments</li></ol></li><li><p>assume an infinite supply of registers</p><ul><li>if it is finite, spilling registers into a tuple and reloading values from this tuple</li></ul></li><li>distinguishable labels and registers</li></ul><div id=outline-container-headline-76 class=outline-4><h4 id=headline-76>TAL syntax</h4><div id=outline-text-headline-76 class=outline-text-4><ul><li><p>TAL machine state:</p><ol><li>heap</li><li>register file</li><li>instructions</li></ol></li></ul></div></div><div id=outline-container-headline-77 class=outline-4><h4 id=headline-77>TAL Operational Semantics</h4><div id=outline-text-headline-77 class=outline-text-4><ul><li>a type-erasure interpretation does not erase the type from the semantics</li></ul></div></div><div id=outline-container-headline-78 class=outline-4><h4 id=headline-78>TAL Static Semantics</h4><div id=outline-text-headline-78 class=outline-text-4><ul><li>specify when programs are well formed and ensure the program will not get stuck</li><li>formation judgments are for heaps + register file + instructions</li></ul></div></div><div id=outline-container-headline-79 class=outline-4><h4 id=headline-79>Code generation</h4><div id=outline-text-headline-79 class=outline-text-4><ul><li><p>For translation of function types, registers are assigned to value arguments</p><ul><li>x = v ⇒ mov r_x, v</li><li>x = v_1 P v_2 ⇒ mov r_x, v1; arith r_x, r_x, v_2</li><li>if0(v, e_1, e_2) ⇒ mov r_tmp, v; bnz r_tmp, ℓ[α]; I_1</li><li>…</li></ul></li></ul></div></div></div></div><div id=outline-container-headline-80 class=outline-3><h3 id=headline-80>Optimization</h3><div id=outline-text-headline-80 class=outline-text-3><ul><li><p>how to reason the soundness of optimization?</p><ul><li>measure the equivalence?</li><li>imaging a code snippet as a block-box <code>B</code>. after some optimization, we can get a block-box <code>B'</code> which generates exactly some output as <code>B</code> for arbitrary input but require less latency.</li><li>that sounds so weird how could know what attributes are lost or kept during the optimization?</li></ul></li></ul></div></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-04-18</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/typesystem/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://st-saint.github.io/typesystem/><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/virtualmachine/ class=prev rel=prev title=VirtualMachine><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>VirtualMachine</a>
<a href=/email/ class=next rel=next title=Email>Email<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.120.4">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://st-saint.github.io/ target=_blank>Yayu Wang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>