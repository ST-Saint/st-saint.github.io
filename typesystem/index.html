<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Type System - Yayu Wang</title><meta name=Description content="This is my cool site"><meta property="og:url" content="https://st-saint.github.io/typesystem/">
<meta property="og:site_name" content="Yayu Wang"><meta property="og:title" content="Type System"><meta property="og:description" content="I don't know what is type system"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-04T22:04:44+00:00"><meta property="article:modified_time" content="2024-03-24T01:30:40-07:00"><meta property="og:image" content="https://st-saint.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://st-saint.github.io/logo.png"><meta name=twitter:title content="Type System"><meta name=twitter:description content="I don't know what is type system"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://st-saint.github.io/typesystem/><link rel=prev href=https://st-saint.github.io/virtualmachine/><link rel=next href=https://st-saint.github.io/email/><link rel=stylesheet href=/css/main.min.css><link rel=stylesheet href=/css/style.min.css><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Type System","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https://st-saint.github.io/typesystem/"},"genre":"posts","wordcount":4267,"url":"https://st-saint.github.io/typesystem/","datePublished":"2023-02-04T22:04:44+00:00","dateModified":"2024-03-24T01:30:40-07:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yayu Wang","url":"https://st-saint.github.io/"},"description":""}</script></head><body data-instant-intensity=viewport><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.className=e,document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),e==="light"?document.documentElement.classList.remove("tw-dark"):document.documentElement.classList.add("tw-dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#161b22"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class="desktop print:!tw-hidden" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yayu Wang"><span id=desktop-header-typeit class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=Posts>Posts </a><a class=menu-item href=/archive>Archive </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<button class="search-button search-toggle" id=search-toggle-desktop title=Search>
<svg class="icon" viewBox="0 0 512 512"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</button>
<button class="search-button search-clear" id=search-clear-desktop title=Clear>
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3.0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3.0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3.0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3.0 17L312 256l65.6 65.1z"/></svg>
</button>
<span class="search-button search-loading tw-animate-spin" id=search-loading-desktop><svg class="icon" viewBox="0 0 512 512"><path d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49.0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156.0c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"/></svg>
</span></span><button class="menu-item theme-switch" aria-label="Switch Theme"><svg class="icon" viewBox="0 0 512 512"><path d="M8 256c0 136.966 111.033 248 248 248s248-111.034 248-248S392.966 8 256 8 8 119.033 8 256zm248 184V72c101.705.0 184 82.311 184 184 0 101.705-82.311 184-184 184z"/></svg></button></div></div></div></header><header class="mobile print:!tw-hidden" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yayu Wang"><span id=mobile-header-typeit class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<button class="search-button search-toggle tw-h-10" id=search-toggle-mobile title=Search>
<svg class="icon" viewBox="0 0 512 512"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</button>
<button class="search-button search-clear" id=search-clear-mobile title=Clear>
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3.0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3.0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3.0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3.0 17L312 256l65.6 65.1z"/></svg>
</button>
<span class="search-button search-loading tw-animate-spin" id=search-loading-mobile><svg class="icon" viewBox="0 0 512 512"><path d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49.0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156.0c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"/></svg></span></div><button class=search-cancel id=search-cancel-mobile>
Cancel</button></div><a class=menu-item href=/posts/ title=Posts>Posts</a><a class=menu-item href=/archive title>Archive</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><button class="menu-item theme-switch tw-w-full" aria-label="Switch Theme"><svg class="icon" viewBox="0 0 512 512"><path d="M8 256c0 136.966 111.033 248 248 248s248-111.034 248-248S392.966 8 256 8 8 119.033 8 256zm248 184V72c101.705.0 184 82.311 184 184 0 101.705-82.311 184-184 184z"/></svg></button></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","false")</script><article class="page single print:!tw-w-full print:!tw-max-w-none print:!tw-m-0 print:!tw-p-0"><h1 class=single-title data-pagefind-meta=date:2023-02-04 data-pagefind-body>Type System</h1><div class=post-meta><div class=post-meta-line><span class=post-author><svg class="icon" viewBox="0 0 496 512"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6.0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7.0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4.0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9s28-2.7 40.9-6.9c2.3-.7 4.7-1.1 7.1-1.1 42.9.0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><a href=https://st-saint.github.io/ title=Author target=_blank rel="noopener noreferrer author" class=author>Yayu Wang</a></span></div><div class=post-meta-line><svg class="icon" viewBox="0 0 448 512"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;<time datetime=2023-02-04>2023-02-04</time>&nbsp;<svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg>&nbsp;<time datetime=2024-03-24>2024-03-24</time>&nbsp;<svg class="icon" viewBox="0 0 512 512"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;4267 words&nbsp;
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;19 minutes&nbsp;</div></div><div class="details toc print:!tw-block" id=toc-static kept=true><div class="details-summary toc-title"><span>Contents</span>
<span class=details-icon><svg class="icon" viewBox="0 0 256 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9.0l-22.6-22.6c-9.4-9.4-9.4-24.6.0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6.0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9.0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#headline-1>Terminology</a><ul><li><a href=#headline-2>Judgement</a></li><li><a href=#headline-3>Inference Rules</a><ul><li><a href=#headline-4>Derivation</a><ul><li><a href=#headline-5>Derivation Tree</a></li></ul></li></ul></li><li><a href=#headline-6>Reduction</a></li><li><a href=#headline-7>Substitution</a></li><li><a href=#headline-8>Unification</a></li><li><a href=#headline-9>Deduction</a></li><li><a href=#headline-10>Induction</a></li><li><a href=#headline-11>Continuation</a></li><li><a href=#headline-12>Foreign function interface (FFI)</a></li><li><a href=#headline-13>landin' knot</a></li></ul></li><li><a href=#headline-14>Refinement Types</a><ul><li><a href=#headline-15>Introduction</a><ul><li><a href=#headline-16>passes</a></li></ul></li><li><a href=#headline-17>Simply Typed λ-calculus</a><ul><li><a href=#headline-18>Verification Conditions</a></li><li><a href=#headline-19>arithmetic overflow</a></li></ul></li><li><a href=#headline-20>Branches and Recursion</a></li><li><a href=#headline-21>questions</a><ul><li><a href=#headline-22>Differences between refinement type system and symbolic execution</a></li><li><a href=#headline-23>what would the refinement type system do if the conditions cannot be solved by SMT?</a></li><li><a href=#headline-24>it is a bit confusing that how could you verify termination with a recursion function?</a></li></ul></li></ul></li><li><a href=#headline-25>Sized Types</a><ul><li><a href=#headline-26>productive</a></li><li><a href=#headline-27>Primitive Recursion: Reverse</a><ul><li><a href=#headline-28>Accumulating Parameters</a></li></ul></li><li><a href=#headline-29>Array Bounds Check</a></li><li><a href=#headline-30>questions</a></li></ul></li><li><a href=#headline-31>typing vs typechecking</a><ul><li><a href=#headline-32>本体论(Ontology)</a><ul><li><a href=#headline-33>类型 = 分类？</a></li><li><a href=#headline-34>类型是什么</a></li><li><a href=#headline-35>历史上的类型是什么</a></li><li><a href=#headline-36>类型的意义</a></li></ul></li><li><a href=#headline-37>派生概念</a><ul><li><a href=#headline-38>类型正确(Type Correctness)</a></li><li><a href=#headline-39>类型识别(Type Identification)</a></li><li><a href=#headline-40>类型转换(Type Conversion)</a></li><li><a href=#headline-41>类型安全(Type Safety)</a></li><li><a href=#headline-42>类型检查(Typechecking)</a></li><li><a href=#headline-43>静态/动态 类型</a></li><li><a href=#headline-44>强类型</a></li></ul></li></ul></li><li><a href=#headline-45>Dependent typing</a><ul><li><a href=#headline-46>Formal definition</a><ul><li><a href=#headline-47>Π type</a></li><li><a href=#headline-48>Σ type</a></li></ul></li><li><a href=#headline-49>Extra reading</a><ul><li><a href=#headline-50>Extensional and intensional definitions</a><ul><li><a href=#headline-51>Intensional definition</a></li><li><a href=#headline-52>Extensional definition</a></li></ul></li><li><a href=#headline-53>intuitionistic logic</a></li><li><a href=#headline-54>First-order logic</a></li><li><a href=#headline-55>Curry–Howard correspondence</a><ul><li><a href=#headline-56>General formulation</a></li><li><a href=#headline-57>Hilbert-style deduction systems</a><ul><li><a href=#headline-58>axiom schemes</a></li><li><a href=#headline-59>formalization</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#headline-60>From System F to Typed Assembly Language</a><ul><li><a href=#headline-61>abstract</a><ul><li><a href=#headline-62>question</a></li></ul></li><li><a href=#headline-63>introduction</a><ul><li><a href=#headline-64>SPIN</a></li></ul></li><li><a href=#headline-65>overview</a><ul><li><a href=#headline-66>TAL</a></li><li><a href=#headline-67>type-preserving compiler</a><ul><li><a href=#headline-68>workflow</a></li></ul></li></ul></li><li><a href=#headline-69>System-F</a></li><li><a href=#headline-70>CPS</a></li><li><a href=#headline-71>λ^K</a><ul><li><a href=#headline-72>Translation</a></li></ul></li><li><a href=#headline-73>Simplified polymorphic closure conversion</a><ul><li><a href=#headline-74>Translation</a></li><li><a href=#headline-75>Hoisting</a></li></ul></li><li><a href=#headline-76>Explicit allocation</a><ul><li><a href=#headline-77>Translation</a></li></ul></li><li><a href=#headline-78>Typed Assembly language</a><ul><li><a href=#headline-79>TAL syntax</a></li><li><a href=#headline-80>TAL Operational Semantics</a></li><li><a href=#headline-81>TAL Static Semantics</a></li><li><a href=#headline-82>Code generation</a></li></ul></li><li><a href=#headline-83>Optimization</a></li></ul></li></ul></nav></div></div><div class=content id=content data-pagefind-body><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Terminology</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Judgement</h3><div id=outline-text-headline-2 class=outline-text-3><ul><li>A judgement is something we may know, that is, an object of knowledge</li><li>A judgement is evident if we in fact know it</li><li>\(e:t\) ⇒ the expression e has type t</li><li><p>\(\Gamma\) ⇒ Context: a set of &lt;variable, type> pairs</p><ul><li>\(\vdash\) ⇒ turnstile</li><li>\(\Gamma \vdash e : t\) ⇒ expression e has type t in the context \(\Gamma\)</li><li>\(\Gamma , x:\tau\) ⇒ extends \(\Gamma\) with knowledge: \(x:\tau\)</li></ul></li></ul></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Inference Rules</h3><div id=outline-text-headline-3 class=outline-text-3><ul><li><p>\(\frac{P1\ P2\ P3\ ...}{C}\)</p><ul><li>C ⇒ conclusion</li><li>P ⇒ premise</li><li>If we konw P1 & P2 & P3 then we know C</li></ul></li></ul><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>Derivation</h4><div id=outline-text-headline-4 class=outline-text-4><blockquote><p>In ML, a typing derivation is a proof that some expression can have some type, given a particular context, not that the expression can only have that type or that the expression will have that type no matter where we encounter it.</p><p>a derivation for ρ ⊢ e : t is a proof that in some context ρ (which assigns types to variables in e), we can show that e can have (at least) the type t, and possibly others.</p></blockquote><ul><li>The one-step evaluation relation → is the smallest binary relation on terms</li><li>When the pair (t , t') is in the evaluation relation, we say that "the evaluation statement (or judgment) t → t' is derivable."</li></ul><div id=outline-container-headline-5 class=outline-5><h5 id=headline-5>Derivation Tree</h5><div id=outline-text-headline-5 class=outline-text-5>\begin{equation}
\notag \large \dfrac{\dfrac{\dfrac{x:Bool \in x: Bool}{x:Bool \vdash x:Bool}}{\vdash \lambda x:Bool . x : Bool \rightarrow Bool} \qquad \dfrac{}{\vdash true: Bool} }{\vdash (\lambda x: Bool.x )\ true: Bool}
\end{equation}</div></div></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Reduction</h3><div id=outline-text-headline-6 class=outline-text-3><ul><li><p>Also known as <strong>subject evaluation</strong>, <strong>type preservation</strong> or simply <strong>preservation</strong></p><ol><li>$$\frac{\Gamma \vdash e_1:\tau\qquad e_1 \rightarrow e_2}{\Gamma \vdash e_2:\tau}$$</li><li>$$\frac{}{if\ True\ then\ e1\ else\ e2 \rightarrow e1}$$</li><li>$$\frac{e \Downarrow True}{if\ e\ then\ e1\ else\ e2}$$ $${if\ True\ then\ e1\ else\ e2\ \rightarrow\ e1}$$</li></ol></li></ul></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Substitution</h3><div id=outline-text-headline-7 class=outline-text-3><ul><li>$$[x \rightarrow s]x = s$$</li><li>$$e[x \backslash e^a] == [ x \rightarrow e^a] e$$</li></ul>\begin{align}
& [ x \rightarrow e^{'}](let y=e_1\; in\; e_2 ) \\
= & let y = [x \rightarrow e^{'}]e_1\; in\; [x \rightarrow e^{'}]e_2
\end{align}</div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Unification</h3></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Deduction</h3></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>Induction</h3></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>Continuation</h3></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>Foreign function interface (FFI)</h3></div><div id=outline-container-headline-13 class=outline-3><h3 id=headline-13>landin' knot</h3><div id=outline-text-headline-13 class=outline-text-3><ul><li><p>represent recursion</p><ul><li>13.5.8</li></ul></li></ul></div></div></div></div><div id=outline-container-headline-14 class=outline-2><h2 id=headline-14>Refinement Types</h2><div id=outline-text-headline-14 class=outline-text-2><div id=outline-container-headline-15 class=outline-3><h3 id=headline-15>Introduction</h3><div id=outline-text-headline-15 class=outline-text-3><ul><li><p>programs can do things wrong:</p><ol><li>Divided by zero</li><li>Buffer overflow</li><li><p>mismatched dimension</p><ul><li>wrong type casting</li></ul></li><li><p>logic bug</p><ul><li>integer range [min, max]</li></ul></li><li>Correctness error</li></ol></li><li>Refinement type system uses predicates to enrich the type information</li></ul><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>passes</h4><div id=outline-text-headline-16 class=outline-text-4><ol><li>STLC</li><li>branch conditions – path-sensitive</li><li>infer refinements</li><li>type polymorphism – context-sensitive</li><li>polymorphic data types</li><li>refinement polymorphism for different invariants</li><li>verify termination???</li><li>proof proposition over UDF</li></ol></div></div></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>Simply Typed λ-calculus</h3><div id=outline-text-headline-17 class=outline-text-3><ul><li>primitive constants: <code class=verbatim>nat</code></li><li>primitive operations: <code class=verbatim>add</code></li><li>function type with constrain</li></ul><div id=outline-container-headline-18 class=outline-4><h4 id=headline-18>Verification Conditions</h4><div id=outline-text-headline-18 class=outline-text-4><ul><li>take the annotated program as input and return a VC</li></ul></div></div><div id=outline-container-headline-19 class=outline-4><h4 id=headline-19>arithmetic overflow</h4><div id=outline-text-headline-19 class=outline-text-4><ul><li>seems like we can simply add a upper bound (2^31 or 2^63) to avoid overflow here</li></ul></div></div></div></div><div id=outline-container-headline-20 class=outline-3><h3 id=headline-20>Branches and Recursion</h3><div id=outline-text-headline-20 class=outline-text-3><ul><li>also convert to branches conditions to similar VC</li></ul></div></div><div id=outline-container-headline-21 class=outline-3><h3 id=headline-21>questions</h3><div id=outline-text-headline-21 class=outline-text-3><div id=outline-container-headline-22 class=outline-4><h4 id=headline-22>Differences between refinement type system and symbolic execution</h4><div id=outline-text-headline-22 class=outline-text-4><ul><li>To formally verify the division by, buffer overflow and integer range problems, refinement type system also add predicates and constrains over variable and use SMT solver to resolve these constrains, so what does refinement types do differently? or actually symbolic execution is one component of refinement type system?</li></ul></div></div><div id=outline-container-headline-23 class=outline-4><h4 id=headline-23>what would the refinement type system do if the conditions cannot be solved by SMT?</h4><div id=outline-text-headline-23 class=outline-text-4><ul><li>if the condition cannot be satisfied, then it should be a logic bug?</li></ul></div></div><div id=outline-container-headline-24 class=outline-4><h4 id=headline-24>it is a bit confusing that how could you verify termination with a recursion function?</h4></div></div></div></div></div><div id=outline-container-headline-25 class=outline-2><h2 id=headline-25>Sized Types</h2><div id=outline-text-headline-25 class=outline-text-2><ul><li>Input makes the program unpredictable. The inputs can taint data or even the control-flow, making memory mess and analysis tricky.</li><li><p>Sized type system is to</p><ul><li>check computation of each stream element terminates.</li><li>express bounds on the sizes of recursive data structures.</li></ul></li></ul><div id=outline-container-headline-26 class=outline-3><h3 id=headline-26>productive</h3><div id=outline-text-headline-26 class=outline-text-3><ul><li>a request for the first <code>i</code> element of the stream is guaranteed to be processed in finite time means the program is productive</li><li>I guess <code class=verbatim>head</code> is to read the first element of a stream and <code class=verbatim>tail</code> is the stream excluding the first element</li><li>so we introduce type: <code>ST^i</code> for streams with at least i elements</li><li>using sized types we can infer the lower bounds on the size of all the streams</li><li>if we can claim a function has a type: <code>ST^i -> ST^j && i>j</code> then we can prove termination</li></ul></div></div><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>Primitive Recursion: Reverse</h3><div id=outline-text-headline-27 class=outline-text-3><ul><li>sized type system can prove termination or productivity of functions in primitive recursive form</li></ul><div class="src src-lisp"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=nf>reverse</span> <span class=err>::</span> <span class=nv>\forall</span> <span class=nv>i.</span> <span class=nv>\forall</span> <span class=nv>t.</span> <span class=nv>LIST_i</span> <span class=no>t</span> <span class=nv>-&gt;</span> <span class=nv>LIST_i</span> <span class=no>t</span>
</span></span><span class=line><span class=cl><span class=nf>reverse</span> <span class=nv>xs</span> <span class=nf>=</span>
</span></span><span class=line><span class=cl><span class=nb>case</span> <span class=nv>xs</span> <span class=nv>of</span>
</span></span><span class=line><span class=cl><span class=no>Nil</span> <span class=nv>-&gt;</span> <span class=no>Nil</span>
</span></span><span class=line><span class=cl><span class=nv>Cons</span> <span class=nv>y</span> <span class=nv>ys</span> <span class=nv>-&gt;</span> <span class=nf>append</span> <span class=p>(</span><span class=nf>reverse</span> <span class=nv>ys</span><span class=p>)</span> <span class=p>(</span><span class=nv>Cons</span> <span class=nv>y</span> <span class=no>Nil</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div><ol><li><code class=verbatim>Nil -> Nil</code> has type <code>LIST_{i+1} t</code> (why i+t though)</li><li>append (Reverse ys) (Cons y Nil) :: LIST_{<sub>i+1</sub>} -> t</li></ol><div id=outline-container-headline-28 class=outline-4><h4 id=headline-28>Accumulating Parameters</h4><div id=outline-text-headline-28 class=outline-text-4><ul><li>allow a limited form of polymorphic recursion: over sizes, but not types.</li></ul></div></div></div></div><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>Array Bounds Check</h3><div id=outline-text-headline-29 class=outline-text-3><ul><li><p>We view an array as a function from indices to contents</p><ul><li>an array of t with 6 elements has type <code>NAT_6 -> t</code></li></ul></li></ul></div></div><div id=outline-container-headline-30 class=outline-3><h3 id=headline-30>questions</h3><div id=outline-text-headline-30 class=outline-text-3><ul><li>I guess <code>Mk</code> and <code>ST</code> are all special keywords and <code>ST</code> is stream. However I still don't get what how to combine a <code>NAT</code> and a <code>ST</code></li><li>Sized Type consider the length of the stream instead the value of streams. I think the value of input is also important. For example, the Array Bounds Check problem, a common scenario is the array having a dynamic length (i.e. depends on input), and the length becomes unknown to tpye system. So if we want to constrain the input refinement type sounds more reasonable but it will probably become a SAT problem. Even though I feel memory allocation is still a conflict between efficiency and safety. If you allow dynamically length it is more tricky to prove the safety but you gain some flexibility. Is it possible to combine sized type and refinement type to check more security properties of the program?</li></ul></div></div></div></div><div id=outline-container-headline-31 class=outline-2><h2 id=headline-31>typing vs typechecking</h2><div id=outline-text-headline-31 class=outline-text-2><ul><li>顶不住了, 先看看中文文档吧 <a href=https://github.com/FrankHB/pl-docs/blob/master/zh-CN/typing-vs-typechecking.md>typing-vs-typechecking</a></li></ul><div id=outline-container-headline-32 class=outline-3><h3 id=headline-32>本体论(Ontology)</h3><div id=outline-text-headline-32 class=outline-text-3><ul><li>类型是一种抽象的实体(entity)</li><li>类型不是名称</li></ul><div id=outline-container-headline-33 class=outline-4><h4 id=headline-33>类型 = 分类？</h4><div id=outline-text-headline-33 class=outline-text-4><ul><li>不是</li><li>不是为了对现有对象"分类", 因为被“分类”的对象都是先前毫无意义, 只是通过这个类型才确定的, 而且具有这样类型的值 <strong>只可能有一种完全等价的</strong> 构造方式, 这就是所谓的 <code>unit type</code> 的实例</li></ul></div></div><div id=outline-container-headline-34 class=outline-4><h4 id=headline-34>类型是什么</h4><div id=outline-text-headline-34 class=outline-text-4><ul><li>对于某个类型系统中的类型——这种人为设计中的一份子</li><li>类型系统的设计者或者类型的设计者（类型系统的用户）希望它是什么</li></ul></div></div><div id=outline-container-headline-35 class=outline-4><h4 id=headline-35>历史上的类型是什么</h4><div id=outline-text-headline-35 class=outline-text-4><ul><li><p><a href=https://zh.wikipedia.org/zh-cn/%E7%BD%97%E7%B4%A0%E6%82%96%E8%AE%BA>罗素悖论</a> - <a href=https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E8%AE%BA>类型论</a></p><ul><li>任给一个性质(例如："年满三十岁"就是一个性质)，满足该性质的所有集合总可以组成一个集合</li><li><p>设有一性质P，并以一性质函数表示：P(x)，且其中的自变量x有此特性： x ∉ x，</p><ul><li>不是, x ∉ x 是什么意思</li></ul></li></ul></li><li>我靠我一直觉得 PL 讲的 type 本质都应该是数学集合, 好像还是有点道理, 然而类型系统好像是集合论的上位(也许)替代</li></ul></div></div><div id=outline-container-headline-36 class=outline-4><h4 id=headline-36>类型的意义</h4><div id=outline-text-headline-36 class=outline-text-4><ul><li>各种类型论中, 并没有要求"类型"成为和某种领域外实体的对应, 以作为建模或"分类"的基础, 而仅仅是项 (term) 上关联的一些抽象实体</li></ul></div></div></div></div><div id=outline-container-headline-37 class=outline-3><h3 id=headline-37>派生概念</h3><div id=outline-text-headline-37 class=outline-text-3><div id=outline-container-headline-38 class=outline-4><h4 id=headline-38>类型正确(Type Correctness)</h4><div id=outline-text-headline-38 class=outline-text-4><ul><li>符合期望</li><li><p>类型是开发者对数据、对实体属性的描述, 显式类型是开发者对于程序设计的理解和限定的直接描述</p><ul><li>原文对可读性和重构的考虑脱离实际</li><li>使用 <code>var</code>, <code>auto</code> 借用 Type inference 省去对数据的描述是让开发者在上下文中丢失对数据的理解, 且不便于第三方审阅代码; 在重构时, 考虑代码改动对数据, 对上下文的影响是非常重要且易错的环节, 显式类型要求开发者对语义的改变进行考虑(当然如果开发者匆匆掠过是另一个问题), 类型推断提供了开发便利但不利于保证程序正确性</li><li>即使使用 <code>var</code>, <code>auto</code> ，一个不可忽视的事实是, 编译器生成的 binary 并不包含 <code>var</code> 类型, 实际 runtime 类型有且只有一个具体类型(如果有 runtime type), 如果没有 runtime type 那么数据就只是纯粹的数据而不带任何限制, 这与源代码中 <code>var</code>, <code>auto</code> 所表达的类型不匹配, 而开发者因代码和运行时的差异对程序行为做出错误预测是非常不理想的设计缺陷</li><li>一个可以接受的选择是type system在编译前就将 <code>auto</code> 替换成具体类型</li></ul></li></ul></div></div><div id=outline-container-headline-39 class=outline-4><h4 id=headline-39>类型识别(Type Identification)</h4><div id=outline-text-headline-39 class=outline-text-4><ul><li>要判断类型是否相同, 比较给定的表示类型的数据结构（类型标识）和已知类型的对应数据结构是否相等</li></ul></div></div><div id=outline-container-headline-40 class=outline-4><h4 id=headline-40>类型转换(Type Conversion)</h4><div id=outline-text-headline-40 class=outline-text-4><ul><li>强制(coercion) 是一种隐式转换</li><li>多态(ad-hoc polymorphism) 而和铸型(casting) 显式转换</li></ul></div></div><div id=outline-container-headline-41 class=outline-4><h4 id=headline-41>类型安全(Type Safety)</h4><div id=outline-text-headline-41 class=outline-text-4><ul><li><p>较常用的一种安全机制的基本思路是，定义类型是某个域(domain)中值的集合, 保证类型安全需要考察的值是否总是符合其对应类型的约束.</p><ul><li>判断对象语言描述的程序是否符合类型安全这项任务能被程序表达和实现(包括语言自身的实现, 如编译时的检查).</li><li>这样, 类型安全可以视为某一些语言规则中蕴含的性质</li><li>当语言的规则不足以保证它表达的任意操作产生的值属于规则事先指定的值的集合之内, 这些规则就不是安全的</li></ul></li><li><p>安全一般考虑两个方面, 一个是 confidentiality, 一个是 integrity</p><ul><li>未定义行为说成类型不安全其实是符合安全的描述的, 对应 integrity 的 control-flow & information-flow integrity</li></ul></li></ul></div></div><div id=outline-container-headline-42 class=outline-4><h4 id=headline-42>类型检查(Typechecking)</h4><div id=outline-text-headline-42 class=outline-text-4><ul><li><p>现实的类型安全一般通过在语言设计中由两类手段提供支持</p><ol><li>语言的构造性规则限制不安全类型构造的表达 – typing</li><li>语言对潜在不安全的表达进行额外的语义检查 – type checking (广义地也能包含typing)</li></ol></li><li><p>尽管一般实现 typechecking 蕴含解一个判定性问题 – 即作用于代码上判断出一个表示 "通过" 或"不通过"的二元结果, 却并不一定表示接受或者拒绝接受程序</p><ul><li>一条语言规则不会因为实现要求附加其它行为或不要求任何可预测的行为 (所谓未定义行为) 而不适合归类为 typechecking 规则; 举例: C 的许多使用非兼容类型 (compatible type) 的值的操作是未定义行为, 这不是 typing, 而指定了作用于指针类型上的 typechecking</li></ul></li></ul></div></div><div id=outline-container-headline-43 class=outline-4><h4 id=headline-43>静态/动态 类型</h4><div id=outline-text-headline-43 class=outline-text-4><ul><li>静态类型或者动态类型都和 typing 的时机有关; 而单纯静态/动态, 对彻底不提供类型系统设计的 typeless 的语言都可能说得通</li></ul></div></div><div id=outline-container-headline-44 class=outline-4><h4 id=headline-44>强类型</h4><div id=outline-text-headline-44 class=outline-text-4><ul><li>强类型 (strong type/strong typing/strongly typed)</li><li>manifest typing/latent typing</li></ul></div></div></div></div></div></div><div id=outline-container-headline-45 class=outline-2><h2 id=headline-45>Dependent typing</h2><div id=outline-text-headline-45 class=outline-text-2><ul><li>a dependent type is a type whose definition depends on a value</li><li><p>dependent types are used to encode logic's quantifiers like "for all" and "there exists"</p></li></ul><ul><li><p>Two common examples of dependent types are dependent functions, which correspond to "for all" and dependent pairs, which correspond to "there exists". The return type of a dependent function may depend on the value (not just type) of one of its arguments.</p></li><li><p>Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result</p><ul><li>the decidability of type checking may depend on the given type theory's semantics of equality, that is, whether the type theory is intensional or extensional.</li></ul></li></ul><div id=outline-container-headline-46 class=outline-3><h3 id=headline-46>Formal definition</h3><div id=outline-text-headline-46 class=outline-text-3><div id=outline-container-headline-47 class=outline-4><h4 id=headline-47>Π type</h4><div id=outline-text-headline-47 class=outline-text-4><ul><li>dependent types are similar to the type of an indexed family of sets</li><li>formally, given a type <code>A: U</code> in a universe of types <code>U</code>, one may have a family of types <code>B: A \to U</code>, which assigns to each term <code>a: A</code> a type <code>B(a): U</code>. We say that the type <code>B(a)</code> varies with <code>a</code>.</li><li><p>A function whose type of return value varies with its argument (i.e. there is no fixed codomain) is a dependent function and the type of this function is called dependent product type, pi-type (Π type) or dependent function type.</p><ul><li>Written as <code>\Pi_{(x:A)} B(x)</code></li></ul></li></ul></div></div><div id=outline-container-headline-48 class=outline-4><h4 id=headline-48>Σ type</h4><div id=outline-text-headline-48 class=outline-text-4><ul><li>The dual of the dependent product type is the dependent pair type, dependent sum type, sigma-type</li><li>If, in the universe of types <code>U</code>, there is a type <code>A: U</code> and a family of types <code>B: A \to U</code>, then there is a dependent pair type <code>\sum_{x:A} B(x)</code></li><li>The dependent pair type captures the idea of an ordered pair where the type of the second term is dependent on the value of the first. If <code>(a,b):\sum_{x:A}B(x)</code> then <code>a: A</code> and <code>b: B(a)</code></li></ul></div></div></div></div><div id=outline-container-headline-49 class=outline-3><h3 id=headline-49>Extra reading</h3><div id=outline-text-headline-49 class=outline-text-3><div id=outline-container-headline-50 class=outline-4><h4 id=headline-50>Extensional and intensional definitions</h4><div id=outline-text-headline-50 class=outline-text-4><div id=outline-container-headline-51 class=outline-5><h5 id=headline-51>Intensional definition</h5><div id=outline-text-headline-51 class=outline-text-5><ul><li>An intensional definition gives meaning to a term by specifying necessary and sufficient conditions for when the term should be used.</li><li>intensional definitions are best used when something has a clearly defined set of properties, and they work well for terms that have too many referents to list in an extensional definition.</li></ul></div></div><div id=outline-container-headline-52 class=outline-5><h5 id=headline-52>Extensional definition</h5><div id=outline-text-headline-52 class=outline-text-5><ul><li>An extensional definition gives meaning to a term by specifying its extension, that is, every object that falls under the definition of the term in question.</li><li>An explicit listing of the extension, which is only possible for finite sets and only practical for relatively small sets, is a type of enumerative definition.</li><li>Extensional definitions are used when listing examples would give more applicable information than other types of definition, and where listing the members of a set tells the questioner enough about the nature of that set.</li></ul><blockquote><p>A fundamental distinction is extensional vs intensional type theory. In extensional type theory, definitional (i.e., computational) equality is not distinguished from propositional equality, which requires proof. As a consequence type checking becomes undecidable in extensional type theory because programs in the theory might not terminate. For example, such a theory allows one to give a type to the Y-combinator; a detailed example of this can be found in Nordstöm and Petersson Programming in Martin-Löf's Type Theory.[2] However, this does not prevent extensional type theory from being a basis for a practical tool; for example, NuPRL is based on extensional type theory.</p></blockquote></div></div></div></div><div id=outline-container-headline-53 class=outline-4><h4 id=headline-53>intuitionistic logic</h4><div id=outline-text-headline-53 class=outline-text-4><ul><li><p>In the semantics of classical logic, propositional formulae are assigned truth values from the two-element set <code>\top, \bot</code> ("true" and "false" respectively)</p><ul><li>This is referred to as the 'law of excluded middle', because it excludes the possibility of any truth value besides 'true' or 'false'</li></ul></li><li>Propositional formulae in intuitionistic logic are not assigned a definite truth value and are only considered "true" when we have direct evidence, hence proof.</li><li>if there is a constructive proof that an object exists, that constructive proof may be used as an algorithm for generating an example of that object, a principle known as the Curry–Howard correspondence between proofs and algorithms.</li><li>the double negation of the law is retained as a tautology of the system: that is, it is a theorem that <code>\neg(\neg (P \vee \neg P))</code> regardless of the proposition <code>P</code></li><li>In intuitionistic logic, only <code>P \rightarrow \neg\neg P</code> is theorem, <code>\neg\neg P \rightarrow P</code> is not</li></ul></div></div><div id=outline-container-headline-54 class=outline-4><h4 id=headline-54>First-order logic</h4><div id=outline-text-headline-54 class=outline-text-4><ul><li>First-order logic—also known as predicate logic, quantificational logic, and first-order predicate calculus</li><li>Predicate logic is an extension of propositional logic, adding quantifiers.</li></ul></div></div><div id=outline-container-headline-55 class=outline-4><h4 id=headline-55>Curry–Howard correspondence</h4><div id=outline-text-headline-55 class=outline-text-4><ul><li><p>Curry–Howard correspondence (also known as the Curry–Howard isomorphism or equivalence) is the direct relationship between computer programs and mathematical proofs.</p><ul><li>A proof is a program, and the formula it proves is the type for the program</li></ul></li></ul><div id=outline-container-headline-56 class=outline-5><h5 id=headline-56>General formulation</h5><div id=outline-text-headline-56 class=outline-text-5><table><tbody><tr><td>Logic side</td><td>Programming side</td></tr><tr><td>universal quantification</td><td>generalised product type (Π type)</td></tr><tr><td>existential</td><td>quantification generalised sum type (Σ type)</td></tr><tr><td>implication</td><td>function type</td></tr><tr><td>conjunction</td><td>product type</td></tr><tr><td>disjunction</td><td>sum type</td></tr><tr><td>true formula</td><td>unit type or top type</td></tr><tr><td>false formula</td><td>empty type or bottom type</td></tr><tr><td>hypotheses</td><td>free variables</td></tr><tr><td>implication elimination (modus ponens)</td><td>application</td></tr><tr><td>implication introduction</td><td>abstraction</td></tr><tr><td>assumption</td><td>variable</td></tr><tr><td>axiom schemes</td><td>combinators</td></tr><tr><td>modus ponens</td><td>application</td></tr><tr><td>deduction theorem</td><td>abstraction elimination</td></tr></tbody></table></div></div><div id=outline-container-headline-57 class=outline-5><h5 id=headline-57>Hilbert-style deduction systems</h5><div id=outline-text-headline-57 class=outline-text-5><div id=outline-container-headline-58 class=outline-6><h6 id=headline-58>axiom schemes</h6><div id=outline-text-headline-58 class=outline-text-6><ol><li><p>α → (β → α)</p><ol><li>K: λ xy.x</li></ol></li><li><p>(α → (β → γ)) → ((α → β) → (α → γ))</p><ol><li>S: λ xyz.(x z (y z))</li></ol></li></ol></div></div><div id=outline-container-headline-59 class=outline-6><h6 id=headline-59>formalization</h6><div id=outline-text-headline-59 class=outline-text-6><ul><li><p>Let Γ be a finite collection of formulas, considered as hypotheses. Then δ is derivable from Γ, denoted Γ ⊢ δ, in the following cases:</p><ol><li>δ is an hypothesis, i.e. it is a formula of Γ,</li><li><p>δ is an instance of an axiom scheme; i.e., under the most common axiom system:</p><ol><li>δ has the form α → (β → α), or</li><li>δ has the form (α → (β → γ)) → ((α → β) → (α → γ)),</li></ol></li><li>δ follows by deduction, i.e., for some α, both α → δ and α are already derivable from Γ (this is the rule of modus ponens)</li></ol></li></ul></div></div></div></div></div></div></div></div></div></div><div id=outline-container-headline-60 class=outline-2><h2 id=headline-60>From System F to Typed Assembly Language</h2><div id=outline-text-headline-60 class=outline-text-2><div id=outline-container-headline-61 class=outline-3><h3 id=headline-61>abstract</h3><div id=outline-text-headline-61 class=outline-text-3><ul><li>type-preserving transformation from the System-F to Typed Assembly Language (TAL)</li><li>admit low-level compiler optimization</li><li>CPS & A polymorphic closure conversion phases</li><li>Get type-correct source program and map it to type-correct ASM</li><li>Compiler</li></ul><div id=outline-container-headline-62 class=outline-4><h4 id=headline-62>question</h4><div id=outline-text-headline-62 class=outline-text-4><ul><li><span style=text-decoration:underline>suitable for use in systems where untrusted and potentially malicious code must be checked for safety before execution.</span> but in untrusted environment usually we could only access binary without source code</li><li>CPS conversion, closure conversion, unboxing, subsumption elimination, or region inference</li></ul></div></div></div></div><div id=outline-container-headline-63 class=outline-3><h3 id=headline-63>introduction</h3><div id=outline-text-headline-63 class=outline-text-3><ul><li>some type information are lost</li><li><p>admits most conventional low-level optimizations such as</p><ol><li>global register allocation</li><li>copy propagation</li><li>constant folding</li><li>dead-code elimination.</li></ol></li><li class=unchecked><span style=text-decoration:underline>Except for a small number of atomic code patterns</span>. What patterns?</li><li><p>support code motion</p><ol><li>instruction scheduling</li><li>common-subexpression</li><li>elimination</li><li>loop-invariant removal</li></ol></li><li><p>not support</p><ol><li>run-time code generation</li><li>intensional polymorphism</li><li>array bounds check elimination</li></ol></li></ul><div id=outline-container-headline-64 class=outline-4><h4 id=headline-64>SPIN</h4><div id=outline-text-headline-64 class=outline-text-4><ul><li>type-check in Linux kernel</li></ul></div></div></div></div><div id=outline-container-headline-65 class=outline-3><h3 id=headline-65>overview</h3><div id=outline-text-headline-65 class=outline-text-3><div id=outline-container-headline-66 class=outline-4><h4 id=headline-66>TAL</h4></div><div id=outline-container-headline-67 class=outline-4><h4 id=headline-67>type-preserving compiler</h4><div id=outline-text-headline-67 class=outline-text-4><div id=outline-container-headline-68 class=outline-5><h5 id=headline-68>workflow</h5><div id=outline-text-headline-68 class=outline-text-5><ol><li>λ^F -> CPS conversion</li><li>λ^k -> Closure conversion</li><li>λ^C -> Hoisting</li><li>λ^H -> Allocation</li><li>λ^A -> Code Generation</li></ol></div></div></div></div></div></div><div id=outline-container-headline-69 class=outline-3><h3 id=headline-69>System-F</h3><div id=outline-text-headline-69 class=outline-text-3><ul><li>polymorphic λ-calculus</li></ul></div></div><div id=outline-container-headline-70 class=outline-3><h3 id=headline-70>CPS</h3><div id=outline-text-headline-70 class=outline-text-3><ul><li>continuation passnig style – eliminates the need for a control stack</li><li>all unconditional control transfer: function invocation and return are achieved via function call.</li></ul></div></div><div id=outline-container-headline-71 class=outline-3><h3 id=headline-71>λ^K</h3><div id=outline-text-headline-71 class=outline-text-3><ul><li>λ^K consists of a series of let bindings followed by a function call</li><li>only one abstraction for both type and value variables</li><li class=unchecked>halt?</li><li>functions do not return values but it just jumps</li><li>expression never return values</li><li>∆; Γ ⊢_K e indicates that the term e is well formed</li></ul><div id=outline-container-headline-72 class=outline-4><h4 id=headline-72>Translation</h4><div id=outline-text-headline-72 class=outline-text-4><ul><li><code>K_exp 〚 e 〛</code> takes a continuation k, computes the value of e and hands that value to k</li><li class=unchecked>variable capture?</li><li class=unchecked>can all STLC be transformed into CPS?</li><li>a realistic CPS-converter would eliminate "administrative" redices and optimize tail recursion</li></ul></div></div></div></div><div id=outline-container-headline-73 class=outline-3><h3 id=headline-73>Simplified polymorphic closure conversion</h3><div id=outline-text-headline-73 class=outline-text-3><ul><li><p>Making closure explicit and therby separating program code from data</p><ol><li class=unchecked><p>rewrite functions so that there is no free varaibles. how?</p><ol><li>function calls are performed by calling code with the environment as an addtional argument</li></ol></li><li>hoisting: lift the code blocks to the top of the program</li><li>adopt the type-erasure interpretation of polymorphism which substitude the free type variables directly into code blocks</li></ol></li></ul><div id=outline-container-headline-74 class=outline-4><h4 id=headline-74>Translation</h4><div id=outline-text-headline-74 class=outline-text-4><ul><li><code>C〚·〛</code>: β represent the type of the value environment for the closure</li></ul></div></div><div id=outline-container-headline-75 class=outline-4><h4 id=headline-75>Hoisting</h4><div id=outline-text-headline-75 class=outline-text-4><ul><li><code class=verbatim>fix</code> is no longer a value form.</li><li>code blocks are defined by <code class=verbatim>letrec</code> prefix</li><li class=unchecked><code class=verbatim>letrec</code> and mutually recursive and CPS?</li></ul></div></div></div></div><div id=outline-container-headline-76 class=outline-3><h3 id=headline-76>Explicit allocation</h3><div id=outline-text-headline-76 class=outline-text-3><ul><li>eliminate the value form for tuples</li><li><p>introduce new declaration forms for allocating and initializing tuples</p><ul><li>n-element tuple can be separated into an allocation and n initialization</li></ul></li></ul><div id=outline-container-headline-77 class=outline-4><h4 id=headline-77>Translation</h4><div id=outline-text-headline-77 class=outline-text-4><ul><li class=unchecked>memory layout of nested structure?</li></ul></div></div></div></div><div id=outline-container-headline-78 class=outline-3><h3 id=headline-78>Typed Assembly language</h3><div id=outline-text-headline-78 class=outline-text-3><ul><li><p>simultaneously abstract</p><ol><li>a type environment</li><li>a set of type arguments</li><li>a set of value arguments</li></ol></li><li><p>assume an infinite supply of registers</p><ul><li>if it is finite, spilling registers into a tuple and reloading values from this tuple</li></ul></li><li>distinguishable labels and registers</li></ul><div id=outline-container-headline-79 class=outline-4><h4 id=headline-79>TAL syntax</h4><div id=outline-text-headline-79 class=outline-text-4><ul><li><p>TAL machine state:</p><ol><li>heap</li><li>register file</li><li>instructions</li></ol></li></ul></div></div><div id=outline-container-headline-80 class=outline-4><h4 id=headline-80>TAL Operational Semantics</h4><div id=outline-text-headline-80 class=outline-text-4><ul><li>a type-erasure interpretation does not erase the type from the semantics</li></ul></div></div><div id=outline-container-headline-81 class=outline-4><h4 id=headline-81>TAL Static Semantics</h4><div id=outline-text-headline-81 class=outline-text-4><ul><li>specify when programs are well formed and ensure the program will not get stuck</li><li>formation judgments are for heaps + register file + instructions</li></ul></div></div><div id=outline-container-headline-82 class=outline-4><h4 id=headline-82>Code generation</h4><div id=outline-text-headline-82 class=outline-text-4><ul><li><p>For translation of function types, registers are assigned to value arguments</p><ul><li>x = v ⇒ mov r_x, v</li><li>x = v_1 P v_2 ⇒ mov r_x, v1; arith r_x, r_x, v_2</li><li>if0(v, e_1, e_2) ⇒ mov r_tmp, v; bnz r_tmp, ℓ[α]; I_1</li><li>…</li></ul></li></ul></div></div></div></div><div id=outline-container-headline-83 class=outline-3><h3 id=headline-83>Optimization</h3><div id=outline-text-headline-83 class=outline-text-3><ul><li><p>how to reason the soundness of optimization?</p><ul><li>measure the equivalence?</li><li>imaging a code snippet as a block-box <code>B</code>. after some optimization, we can get a block-box <code>B'</code> which generates exactly some output as <code>B</code> for arbitrary input but require less latency.</li><li>that sounds so weird how could know what attributes are lost or kept during the optimization?</li></ul></li></ul></div></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2024-03-24</span></div><div class=post-info-license></div></div><div class="post-info-line print:!tw-hidden"><div class=post-info-md><span><a class=link-to-mardown href=/typesystem/index.md target=_blank rel="noopener noreferrer">Read markdown</a></span></div><div class=post-info-share><button title="Share on Twitter" data-sharer=twitter data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><svg class="icon" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></button><button title="Share on Facebook" data-sharer=facebook data-url=https://st-saint.github.io/typesystem/><svg class="icon" viewBox="0 0 512 512"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></button><button title="Share on Hacker News" data-sharer=hackernews data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><svg class="icon" viewBox="0 0 448 512"><path d="M0 32v448h448V32H0zm21.2 197.2H21c.1-.1.2-.3.3-.4.0.1.0.3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"/></svg></button><button title="Share on Line" data-sharer=line data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><svg class="icon" role="img" viewBox="0 0 24 24"><title>LINE</title><path d="M19.365 9.863c.349.0.63.285.63.631.0.345-.281.63-.63.63H17.61v1.125h1.755c.349.0.63.283.63.63.0.344-.281.629-.63.629h-2.386c-.345.0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346.0.627.285.627.63.0.349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211.0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346.0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195.0.375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345.0.63.285.63.63v4.771zm-5.741.0c0 .344-.282.629-.631.629-.345.0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346.0.628.285.628.63v4.771zm-2.466.629H4.917c-.345.0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348.0.63.285.63.63v4.141h1.756c.348.0.629.283.629.63.0.344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943.0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/></svg></button><button title="Share on 微博" data-sharer=weibo data-url=https://st-saint.github.io/typesystem/ data-title="Type System"><svg class="icon" viewBox="0 0 512 512"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7.0 395.3.0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"/></svg></button></div></div></div><div class=post-info-more><section class=post-tags></section><section class=print:!tw-hidden><span><button class="tw-text-fgColor-link-muted hover:tw-text-fgColor-link-muted-hover" onclick=window.history.back()>Back</button></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class="post-nav print:tw-hidden"><a href=/virtualmachine/ class=prev rel=prev title=VirtualMachine><svg class="icon" viewBox="0 0 256 512"><path d="M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9.0l22.6 22.6c9.4 9.4 9.4 24.6.0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6.0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9.0l-136-136c-9.5-9.4-9.5-24.6-.1-34z"/></svg>VirtualMachine</a>
<a href=/email/ class=next rel=next title=Email>Email<svg class="icon" viewBox="0 0 256 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9.0l-22.6-22.6c-9.4-9.4-9.4-24.6.0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6.0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9.0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.135.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg> DoIt</a></div><div class=footer-line><svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 448c-110.532.0-2e2-89.451-2e2-2e2.0-110.531 89.451-2e2 2e2-2e2 110.532.0 2e2 89.451 2e2 2e2.0 110.532-89.451 2e2-2e2 2e2zm107.351-101.064c-9.614 9.712-45.53 41.396-104.065 41.396-82.43.0-140.484-61.425-140.484-141.567.0-79.152 60.275-139.401 139.762-139.401 55.531.0 88.738 26.62 97.593 34.779a11.965 11.965.0 011.936 15.322l-18.155 28.113c-3.841 5.95-11.966 7.282-17.499 2.921-8.595-6.776-31.814-22.538-61.708-22.538-48.303.0-77.916 35.33-77.916 80.082.0 41.589 26.888 83.692 78.277 83.692 32.657.0 56.843-19.039 65.726-27.225 5.27-4.857 13.596-4.039 17.82 1.738l19.865 27.17a11.947 11.947.0 01-1.152 15.518z"/></svg>2019 - 2025<span class=author>&nbsp;<a href=https://st-saint.github.io/ target=_blank rel="noopener noreferrer">Yayu Wang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons class=print:!tw-hidden><a href=#back-to-top id=back-to-top-button class="fixed-button tw-transition-opacity tw-opacity-0" title="Back to Top"><svg class="icon" viewBox="0 0 448 512"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><div id=cookieconsent-container></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script>window.config={"autocomplete.min.js":"/lib/autocomplete/autocomplete.min.js",comment:{},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"desktop-header-typeit":'<i class="nf nf-custom-emacs"></i> Home',"mobile-header-typeit":'<i class="nf nf-custom-emacs"></i> Home'},"fuse.min.js":"/lib/fuse/fuse.min.js",math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:null,findAllMatches:null,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:null,ignoreLocation:null,isCaseSensitive:null,location:null,maxResultLength:10,minMatchCharLength:null,noResultsFound:"No results found",snippetLength:30,threshold:null,type:"fuse",useExtendedSearch:null},sharerjs:!0,typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},duration:-1,speed:100}}</script><script src=/lib/sharer/sharer.min.js></script><script src=/lib/typeit/typeit.min.js></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/js/katex.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/js/cookieconsent.min.js defer></script><script src=/js/theme.min.js defer></script><script type=speculationrules>
        {
          "prerender": [
            {
              "where": { "href_matches": "/*" },
              "eagerness": "moderate"
            }
          ]
        }
    </script></body></html>